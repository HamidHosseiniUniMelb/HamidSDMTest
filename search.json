[
  {
    "objectID": "P8_network.html",
    "href": "P8_network.html",
    "title": "HamidSDMTestWeb",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "P4_logical.html",
    "href": "P4_logical.html",
    "title": "[P4] Logical design",
    "section": "",
    "text": "In last week’s practical class, you conducted requirements analysis and conceptual design for a simple company scenario. Now you can progress to a refinement.\nIn the logical step, you explicitly consider the target type of DBMS (database management system) – in this case, a relational DBMS. You model your data storage structures (relation schemas) in a manner that supports all the requirements for data integrity maintenance.\n\n\nIn contrast to conceptual design, logical design is much more of a science than an art.\nIn fact, the process can be broken down into a kind of algorithm, which will give good results if you have done your conceptual design properly and thoroughly.\n\nConvert entities to relations (tables).\n\n\nEmployee\n\n\nConvert attributes to columns.\n\nAlso identify the data type for each column.\nIf a column must always have a value for every row of the table, mark it as “NOT NULL” (a special kind of domain constraint).\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text …\n\n\nIf the table already has a clear identifying attribute(s), make it (them) the primary key (underlined). Otherwise add a surrogate key.\n\nRemember to impose the entity integrity constraint – primary keys can never be null.\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text …\n\n\nResolve relationships by adding foreign keys as described in the lecture.\n\nFor an M:N relationship, create an associative entity, a new linking table that contains foreign keys pointing to the tables participating in the relationship.\nTotal participation constraints become NOT NULL constraints on the foreign key.\n\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text departmentID integer NOT NULL …\n\n\n\n\n\n\n\n\n\n\nDepartment departmentID integer NOT NULL …\n\n\n\nPlace relationship attributes in the same table as the foreign key, or in the associative entity if applicable.\nNormalise your tables:\n\n1NF - see note below about multivalued attributes\nTables should already satisfy 2NF and 3NF if you created a clean conceptual model\n\nIdentify attributes that are spatial data types, and decide as much as possible on the data type (vector, raster), types of geometries (point, line, polygon, …) and other properties (dimensionality, Spatial Reference System). Some of this will only become clear once you start sourcing data, possibly after this stage of the process.\nConsider any constraints that you have not been able to implement in the logical model. Identify where you may need to maintain data integrity using triggers. Try to minimise their use. Decide if the trigger is run on INSERT, UPDATE, or DELETE of a record. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required.\n\n\n\n\n\n\n\ngeometry data type\n\n\n\nIn database design, spatial data cannot be treated as ordinary strings or numbers (conventional attributes) because it carries additional semantics: location, shape, and the spatial reference system identifier (SRID). Without spatial awareness, the database cannot recognise whether the data represents a POINT, LINE, or POLYGON, nor can it identify the coordinate reference system (CRS) in use. Moreover, if spatial data is stored as plain text or numeric values, spatial functions (useful for a wide range of spatial analysis and querying tasks such as computing distances and checking overlaps) cannot be applied. To overcome these limitations, PostGIS introduces specialised data types for storing spatial data. The most used are the geometry and geography data types for vectors (POINTS, LINES, or POLYGONS). A geometry/geography column stores the spatial representation of an object in a way that PostgreSQL and PostGIS understand. When a geometry/geography column is defined, it carries with it the shape, the coordinates of the vertices, and the CRS identified by its SRID. Hence, geometrical and topological queries can be easily applied. However, the value of a geometry/geography column is in Well-Known Binary (WKB) format which is useful to read geometry but not easily interpretable by humans. In this regard, to find out basic but foundational information about geometry/geography columns (e.g., geometry type, coordinates of vertices, and SRID), you can use the functions GeometryType, ST_AsText, and ST_SRID as shown below for us_cities table:\nSELECT  location,                -- Returns the Well-Known Binary (WKB) representation of the geometry/geography\n        GeometryType(location),  -- Returns the type of the geometry as a string. Eg: 'LINESTRING', 'MULTIPOINT', etc.\n        ST_AsText(location),     -- Returns the Well-Known Text (WKT) representation of the geometry/geography\n        ST_SRID(location)        -- Returns the spatial reference identifier\nFROM spatial.us_cities;\nBy defining a geometry/geography column, the column’s data type will be USER-DEFINED and the column’s udt_name will be geometry or geography in PostgreSQL. USER-DEFINED means the column uses a custom data type created by an extension (e.g., PostGIS) or user rather than a built-in SQL type. udt_name tells us the actual geometry data type used in the column. The following query shows how to find out data type and udt_name oof the columns in the victoria_police_stations table:\nSELECT table_name, column_name, data_type, udt_name\nFROM information_schema.columns\nWHERE table_schema = 'spatial' AND table_name = 'victoria_police_stations';\nWhen designing conceptual and logical data models, it is important to distinguish between descriptive attributes (e.g., name, ID) and spatial attributes (geometry). For spatial entities, these should be mapped into database structures that accurately represent both their descriptive and spatial characteristics. The following example demonstrates how to create a table to achieve this:\n-- Example: Creating a spatial table in PostGIS\nCREATE TABLE user_schema.land_parcels (\n    parcel_id SERIAL PRIMARY KEY,          -- Descriptive attribute\n    owner_name VARCHAR(100),               -- Descriptive attribute\n    land_use   VARCHAR(50),                -- Descriptive attribute\n    area_m2    NUMERIC,                    -- Descriptive attribute\n    geom       geometry(Polygon, 7855)     -- Spatial attribute (Polygon, SRID 7855 = GDA2020 / MGA Zone 55)\n);\n\n-- Add a spatial index to speed up queries\nCREATE INDEX parcels_geom_idx\n    ON user_schema.land_parcels\n    USING GIST (geom);\n\n\n\n\n\n\n\n\nMultivalued, composite and derived attributes\n\n\n\nMultivalued, composite and derived attributes are an awkward fit for the traditional table-based model of a relational database. First normal form (1NF) requires that each “cell” of a table contains a single atomic value.\nIf you have studied other database subjects, you might have learned to resolve these attributes like this:\n\nResolve a multivalued attribute by splitting it into a separate table, associated to the original table with a one-to-many identifying relationship.\nResolve a composite attribute by simply adding its component parts to the table as individual columns.\nRemove derived attributes from the model, as they can be handled in your application layer.\n\nHowever, Postgres offers additional data types which allow us to store multiple pieces of data in a single field, in a way that is understood by the database query engine.\nDespite technically violating 1NF, these storage methods can nonetheless be very useful. Here is a modern perspective on the above recipe:\n\nMultivalued attributes could be stored using an Array data type (non-spatial), or as Multi* or GeometryCollection geometry columns (spatial).\nComposite attributes could, in some situations, be stored using the powerful jsonb data type.\nDerived attributes can be resolved as generated columns, stored procedures, triggers, or simply removed entirely. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required.\n\n\n\n\n\n\n\n\n\n\n\n\nYour Turn\n\n\n\nStarting from the conceptual design you completed in last week’s practical, prepare a logical design for the employee/department/project database scenario.\n\n\nFor the expression of the model, you can use any drawing technique you wish:\n\npen and paper;\na diagramming tool such as draw.io\na dedicated ER modelling tool, such as the ERD Tool in PGAdmin https://www.pgadmin.org/docs/pgadmin4/development/erd_tool.html. This uses a different notation than the one used previously for conceptual modelling – this is part of the logical design step, and ties the design of your tables to the creation of table schemas.\n\n\n\n\nYou are expected to present a logical design as part of Assignment 2. It will help you to think of other aspects of the project (look at all the project specification as well Assignments 4 and 5) as some aspects of the logical design would benefit from knowledge/anticipation of subsequent steps.\nFor the rest of the session, continue working on your group’s conceptual model for Assignment 2. Begin the logical model when you think you have completed your conceptual model."
  },
  {
    "objectID": "P4_logical.html#from-conceptual-to-logical-design",
    "href": "P4_logical.html#from-conceptual-to-logical-design",
    "title": "[P4] Logical design",
    "section": "",
    "text": "In contrast to conceptual design, logical design is much more of a science than an art.\nIn fact, the process can be broken down into a kind of algorithm, which will give good results if you have done your conceptual design properly and thoroughly.\n\nConvert entities to relations (tables).\n\n\nEmployee\n\n\nConvert attributes to columns.\n\nAlso identify the data type for each column.\nIf a column must always have a value for every row of the table, mark it as “NOT NULL” (a special kind of domain constraint).\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text …\n\n\nIf the table already has a clear identifying attribute(s), make it (them) the primary key (underlined). Otherwise add a surrogate key.\n\nRemember to impose the entity integrity constraint – primary keys can never be null.\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text …\n\n\nResolve relationships by adding foreign keys as described in the lecture.\n\nFor an M:N relationship, create an associative entity, a new linking table that contains foreign keys pointing to the tables participating in the relationship.\nTotal participation constraints become NOT NULL constraints on the foreign key.\n\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text departmentID integer NOT NULL …\n\n\n\n\n\n\n\n\n\n\nDepartment departmentID integer NOT NULL …\n\n\n\nPlace relationship attributes in the same table as the foreign key, or in the associative entity if applicable.\nNormalise your tables:\n\n1NF - see note below about multivalued attributes\nTables should already satisfy 2NF and 3NF if you created a clean conceptual model\n\nIdentify attributes that are spatial data types, and decide as much as possible on the data type (vector, raster), types of geometries (point, line, polygon, …) and other properties (dimensionality, Spatial Reference System). Some of this will only become clear once you start sourcing data, possibly after this stage of the process.\nConsider any constraints that you have not been able to implement in the logical model. Identify where you may need to maintain data integrity using triggers. Try to minimise their use. Decide if the trigger is run on INSERT, UPDATE, or DELETE of a record. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required.\n\n\n\n\n\n\n\ngeometry data type\n\n\n\nIn database design, spatial data cannot be treated as ordinary strings or numbers (conventional attributes) because it carries additional semantics: location, shape, and the spatial reference system identifier (SRID). Without spatial awareness, the database cannot recognise whether the data represents a POINT, LINE, or POLYGON, nor can it identify the coordinate reference system (CRS) in use. Moreover, if spatial data is stored as plain text or numeric values, spatial functions (useful for a wide range of spatial analysis and querying tasks such as computing distances and checking overlaps) cannot be applied. To overcome these limitations, PostGIS introduces specialised data types for storing spatial data. The most used are the geometry and geography data types for vectors (POINTS, LINES, or POLYGONS). A geometry/geography column stores the spatial representation of an object in a way that PostgreSQL and PostGIS understand. When a geometry/geography column is defined, it carries with it the shape, the coordinates of the vertices, and the CRS identified by its SRID. Hence, geometrical and topological queries can be easily applied. However, the value of a geometry/geography column is in Well-Known Binary (WKB) format which is useful to read geometry but not easily interpretable by humans. In this regard, to find out basic but foundational information about geometry/geography columns (e.g., geometry type, coordinates of vertices, and SRID), you can use the functions GeometryType, ST_AsText, and ST_SRID as shown below for us_cities table:\nSELECT  location,                -- Returns the Well-Known Binary (WKB) representation of the geometry/geography\n        GeometryType(location),  -- Returns the type of the geometry as a string. Eg: 'LINESTRING', 'MULTIPOINT', etc.\n        ST_AsText(location),     -- Returns the Well-Known Text (WKT) representation of the geometry/geography\n        ST_SRID(location)        -- Returns the spatial reference identifier\nFROM spatial.us_cities;\nBy defining a geometry/geography column, the column’s data type will be USER-DEFINED and the column’s udt_name will be geometry or geography in PostgreSQL. USER-DEFINED means the column uses a custom data type created by an extension (e.g., PostGIS) or user rather than a built-in SQL type. udt_name tells us the actual geometry data type used in the column. The following query shows how to find out data type and udt_name oof the columns in the victoria_police_stations table:\nSELECT table_name, column_name, data_type, udt_name\nFROM information_schema.columns\nWHERE table_schema = 'spatial' AND table_name = 'victoria_police_stations';\nWhen designing conceptual and logical data models, it is important to distinguish between descriptive attributes (e.g., name, ID) and spatial attributes (geometry). For spatial entities, these should be mapped into database structures that accurately represent both their descriptive and spatial characteristics. The following example demonstrates how to create a table to achieve this:\n-- Example: Creating a spatial table in PostGIS\nCREATE TABLE user_schema.land_parcels (\n    parcel_id SERIAL PRIMARY KEY,          -- Descriptive attribute\n    owner_name VARCHAR(100),               -- Descriptive attribute\n    land_use   VARCHAR(50),                -- Descriptive attribute\n    area_m2    NUMERIC,                    -- Descriptive attribute\n    geom       geometry(Polygon, 7855)     -- Spatial attribute (Polygon, SRID 7855 = GDA2020 / MGA Zone 55)\n);\n\n-- Add a spatial index to speed up queries\nCREATE INDEX parcels_geom_idx\n    ON user_schema.land_parcels\n    USING GIST (geom);\n\n\n\n\n\n\n\n\nMultivalued, composite and derived attributes\n\n\n\nMultivalued, composite and derived attributes are an awkward fit for the traditional table-based model of a relational database. First normal form (1NF) requires that each “cell” of a table contains a single atomic value.\nIf you have studied other database subjects, you might have learned to resolve these attributes like this:\n\nResolve a multivalued attribute by splitting it into a separate table, associated to the original table with a one-to-many identifying relationship.\nResolve a composite attribute by simply adding its component parts to the table as individual columns.\nRemove derived attributes from the model, as they can be handled in your application layer.\n\nHowever, Postgres offers additional data types which allow us to store multiple pieces of data in a single field, in a way that is understood by the database query engine.\nDespite technically violating 1NF, these storage methods can nonetheless be very useful. Here is a modern perspective on the above recipe:\n\nMultivalued attributes could be stored using an Array data type (non-spatial), or as Multi* or GeometryCollection geometry columns (spatial).\nComposite attributes could, in some situations, be stored using the powerful jsonb data type.\nDerived attributes can be resolved as generated columns, stored procedures, triggers, or simply removed entirely. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required."
  },
  {
    "objectID": "P4_logical.html#the-simple-scenario",
    "href": "P4_logical.html#the-simple-scenario",
    "title": "[P4] Logical design",
    "section": "",
    "text": "Your Turn\n\n\n\nStarting from the conceptual design you completed in last week’s practical, prepare a logical design for the employee/department/project database scenario.\n\n\nFor the expression of the model, you can use any drawing technique you wish:\n\npen and paper;\na diagramming tool such as draw.io\na dedicated ER modelling tool, such as the ERD Tool in PGAdmin https://www.pgadmin.org/docs/pgadmin4/development/erd_tool.html. This uses a different notation than the one used previously for conceptual modelling – this is part of the logical design step, and ties the design of your tables to the creation of table schemas."
  },
  {
    "objectID": "P4_logical.html#the-project",
    "href": "P4_logical.html#the-project",
    "title": "[P4] Logical design",
    "section": "",
    "text": "You are expected to present a logical design as part of Assignment 2. It will help you to think of other aspects of the project (look at all the project specification as well Assignments 4 and 5) as some aspects of the logical design would benefit from knowledge/anticipation of subsequent steps.\nFor the rest of the session, continue working on your group’s conceptual model for Assignment 2. Begin the logical model when you think you have completed your conceptual model."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Abouttttttttttttttttttttttttt",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HamidSDMTestWeb",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "P6_geometrical.html",
    "href": "P6_geometrical.html",
    "title": "HamidSDMTestWeb",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  }
]