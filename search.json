[
  {
    "objectID": "P8_network.html",
    "href": "P8_network.html",
    "title": "HamidSDMTestWeb",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "P4_logical.html",
    "href": "P4_logical.html",
    "title": "[P4] Logical design",
    "section": "",
    "text": "In last week’s practical class, you conducted requirements analysis and conceptual design for a simple company scenario. Now you can progress to a refinement.\nIn the logical step, you explicitly consider the target type of DBMS (database management system) – in this case, a relational DBMS. You model your data storage structures (relation schemas) in a manner that supports all the requirements for data integrity maintenance.\n\n\nIn contrast to conceptual design, logical design is much more of a science than an art.\nIn fact, the process can be broken down into a kind of algorithm, which will give good results if you have done your conceptual design properly and thoroughly.\n\nConvert entities to relations (tables).\n\n\nEmployee\n\n\nConvert attributes to columns.\n\nAlso identify the data type for each column.\nIf a column must always have a value for every row of the table, mark it as “NOT NULL” (a special kind of domain constraint).\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text …\n\n\nIf the table already has a clear identifying attribute(s), make it (them) the primary key (underlined). Otherwise add a surrogate key.\n\nRemember to impose the entity integrity constraint – primary keys can never be null.\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text …\n\n\nResolve relationships by adding foreign keys as described in the lecture.\n\nFor an M:N relationship, create an associative entity, a new linking table that contains foreign keys pointing to the tables participating in the relationship.\nTotal participation constraints become NOT NULL constraints on the foreign key.\n\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text departmentID integer NOT NULL …\n\n\n\n\n\n\n\n\n\n\nDepartment departmentID integer NOT NULL …\n\n\n\nPlace relationship attributes in the same table as the foreign key, or in the associative entity if applicable.\nNormalise your tables:\n\n1NF - see note below about multivalued attributes\nTables should already satisfy 2NF and 3NF if you created a clean conceptual model\n\nIdentify attributes that are spatial data types, and decide as much as possible on the data type (vector, raster), types of geometries (point, line, polygon, …) and other properties (dimensionality, Spatial Reference System). Some of this will only become clear once you start sourcing data, possibly after this stage of the process.\nConsider any constraints that you have not been able to implement in the logical model. Identify where you may need to maintain data integrity using triggers. Try to minimise their use. Decide if the trigger is run on INSERT, UPDATE, or DELETE of a record. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required.\n\n\n\n\n\n\n\nMultivalued, composite and derived attributes\n\n\n\nMultivalued, composite and derived attributes are an awkward fit for the traditional table-based model of a relational database. First normal form (1NF) requires that each “cell” of a table contains a single atomic value.\nIf you have studied other database subjects, you might have learned to resolve these attributes like this:\n\nResolve a multivalued attribute by splitting it into a separate table, associated to the original table with a one-to-many identifying relationship.\nResolve a composite attribute by simply adding its component parts to the table as individual columns.\nRemove derived attributes from the model, as they can be handled in your application layer.\n\nHowever, Postgres offers additional data types which allow us to store multiple pieces of data in a single field, in a way that is understood by the database query engine.\nDespite technically violating 1NF, these storage methods can nonetheless be very useful. Here is a modern perspective on the above recipe:\n\nMultivalued attributes could be stored using an Array data type (non-spatial), or as Multi* or GeometryCollection geometry columns (spatial).\nComposite attributes could, in some situations, be stored using the powerful jsonb data type.\nDerived attributes can be resolved as generated columns, stored procedures, triggers, or simply removed entirely. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required.\n\n\n\n\n\n\n\n\n\n\n\n\nYour Turn\n\n\n\nStarting from the conceptual design you completed in last week’s practical, prepare a logical design for the employee/department/project database scenario.\n\n\nFor the expression of the model, you can use any drawing technique you wish:\n\npen and paper;\na diagramming tool such as draw.io\na dedicated ER modelling tool, such as the ERD Tool in PGAdmin https://www.pgadmin.org/docs/pgadmin4/development/erd_tool.html. This uses a different notation than the one used previously for conceptual modelling – this is part of the logical design step, and ties the design of your tables to the creation of table schemas.\n\n\n\n\nYou are expected to present a logical design as part of Assignment 2. It will help you to think of other aspects of the project (look at all the project specification as well Assignments 4 and 5) as some aspects of the logical design would benefit from knowledge/anticipation of subsequent steps.\nFor the rest of the session, continue working on your group’s conceptual model for Assignment 2. Begin the logical model when you think you have completed your conceptual model."
  },
  {
    "objectID": "P4_logical.html#from-conceptual-to-logical-design",
    "href": "P4_logical.html#from-conceptual-to-logical-design",
    "title": "[P4] Logical design",
    "section": "",
    "text": "In contrast to conceptual design, logical design is much more of a science than an art.\nIn fact, the process can be broken down into a kind of algorithm, which will give good results if you have done your conceptual design properly and thoroughly.\n\nConvert entities to relations (tables).\n\n\nEmployee\n\n\nConvert attributes to columns.\n\nAlso identify the data type for each column.\nIf a column must always have a value for every row of the table, mark it as “NOT NULL” (a special kind of domain constraint).\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text …\n\n\nIf the table already has a clear identifying attribute(s), make it (them) the primary key (underlined). Otherwise add a surrogate key.\n\nRemember to impose the entity integrity constraint – primary keys can never be null.\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text …\n\n\nResolve relationships by adding foreign keys as described in the lecture.\n\nFor an M:N relationship, create an associative entity, a new linking table that contains foreign keys pointing to the tables participating in the relationship.\nTotal participation constraints become NOT NULL constraints on the foreign key.\n\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text departmentID integer NOT NULL …\n\n\n\n\n\n\n\n\n\n\nDepartment departmentID integer NOT NULL …\n\n\n\nPlace relationship attributes in the same table as the foreign key, or in the associative entity if applicable.\nNormalise your tables:\n\n1NF - see note below about multivalued attributes\nTables should already satisfy 2NF and 3NF if you created a clean conceptual model\n\nIdentify attributes that are spatial data types, and decide as much as possible on the data type (vector, raster), types of geometries (point, line, polygon, …) and other properties (dimensionality, Spatial Reference System). Some of this will only become clear once you start sourcing data, possibly after this stage of the process.\nConsider any constraints that you have not been able to implement in the logical model. Identify where you may need to maintain data integrity using triggers. Try to minimise their use. Decide if the trigger is run on INSERT, UPDATE, or DELETE of a record. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required.\n\n\n\n\n\n\n\nMultivalued, composite and derived attributes\n\n\n\nMultivalued, composite and derived attributes are an awkward fit for the traditional table-based model of a relational database. First normal form (1NF) requires that each “cell” of a table contains a single atomic value.\nIf you have studied other database subjects, you might have learned to resolve these attributes like this:\n\nResolve a multivalued attribute by splitting it into a separate table, associated to the original table with a one-to-many identifying relationship.\nResolve a composite attribute by simply adding its component parts to the table as individual columns.\nRemove derived attributes from the model, as they can be handled in your application layer.\n\nHowever, Postgres offers additional data types which allow us to store multiple pieces of data in a single field, in a way that is understood by the database query engine.\nDespite technically violating 1NF, these storage methods can nonetheless be very useful. Here is a modern perspective on the above recipe:\n\nMultivalued attributes could be stored using an Array data type (non-spatial), or as Multi* or GeometryCollection geometry columns (spatial).\nComposite attributes could, in some situations, be stored using the powerful jsonb data type.\nDerived attributes can be resolved as generated columns, stored procedures, triggers, or simply removed entirely. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required."
  },
  {
    "objectID": "P4_logical.html#the-simple-scenario",
    "href": "P4_logical.html#the-simple-scenario",
    "title": "[P4] Logical design",
    "section": "",
    "text": "Your Turn\n\n\n\nStarting from the conceptual design you completed in last week’s practical, prepare a logical design for the employee/department/project database scenario.\n\n\nFor the expression of the model, you can use any drawing technique you wish:\n\npen and paper;\na diagramming tool such as draw.io\na dedicated ER modelling tool, such as the ERD Tool in PGAdmin https://www.pgadmin.org/docs/pgadmin4/development/erd_tool.html. This uses a different notation than the one used previously for conceptual modelling – this is part of the logical design step, and ties the design of your tables to the creation of table schemas."
  },
  {
    "objectID": "P4_logical.html#the-project",
    "href": "P4_logical.html#the-project",
    "title": "[P4] Logical design",
    "section": "",
    "text": "You are expected to present a logical design as part of Assignment 2. It will help you to think of other aspects of the project (look at all the project specification as well Assignments 4 and 5) as some aspects of the logical design would benefit from knowledge/anticipation of subsequent steps.\nFor the rest of the session, continue working on your group’s conceptual model for Assignment 2. Begin the logical model when you think you have completed your conceptual model."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Abouttttttttttttttttttttttttt",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HamidSDMTestWeb",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "P6_geometrical.html",
    "href": "P6_geometrical.html",
    "title": "HamidSDMTestWeb",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  }
]