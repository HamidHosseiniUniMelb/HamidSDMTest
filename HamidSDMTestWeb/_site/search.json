[
  {
    "objectID": "P8_network.html",
    "href": "P8_network.html",
    "title": "[P8] Network analysis",
    "section": "",
    "text": "By the end of this practical you will:\n\nUnderstand how pgRouting handles network data for network analysis;\nBe able to create and retrieve information about objects based on their embedding in a network structure; and\nPerform specific network analysis tasks and queries.\n\n\n\n\nA network is a collection of objects linked into a structure. The connected (topological) structure of the network is typically represented by a set of nodes, as well as a set of edges (links) which represent connectivity between pairs of nodes. Edges in the network may be directed or undirected.\nA network may capture, for instance, the fabric of streets or railways connecting houses, suburbs and cities.\nTo practice network analysis inside our PostgreSQL database, we will be using pgRouting. This PostgreSQL extension provides a collection of algorithms for solving network analysis problems, including traversal, routing and accessibility analysis.\n\n\n\n\n\n\nNote\n\n\n\nA set of SQL queries of interest enabling to demonstrate how you build a network topology in PGRouting, a script is here: Network analysis.\n\n\n\n\nThe official documentation for pgRouting lists all available functions and describes how they work. The material is very rough and sometimes difficult to understand, however, it should still give you a general idea of what to do.\nMake sure you are reading the documentation for the correct version, as pgRouting is under active development. To check the pgRouting version on Wammawatcha, run the following SQL query:\nSELECT pgr_version();\n\n\n\n\nIn this section, you will:\n\nlearn how to store a network in a relational DB, and\nlearn how to find shortest paths using pgRouting.\n\n\n\nAs discussed in this week’s lecture, one of the ways to store a network in a database is by forming an edge list.\nEach edge is written in terms of its two connected nodes. For example, an edge between node 9 and node 12 is written as 9,12.\nThe edge list can be implemented as a simple database table called an edge table. In this, each edge is given an id, and we store the source and target nodes of that edge:\n\n\n\nedge_id\nsource\ntarget\n\n\n\n\n15\n9\n12\n\n\n16\n4\n9\n\n\n…\n…\n…\n\n\n\nThe edge table can contain any other required attributes as additional columns. For instance, in a road network, the edge table could include “name” and “speed limit” attributes.\nOptionally, we can also create a node table to store the id and location (geom) of each node, and any other attributes such as node name:\n\n\n\nnode_id\ngeom\n\n\n\n\n1\nPOINT (2 0)\n\n\n2\nPOINT (2 1)\n\n\n…\n…\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAlthough we are mixing pgRouting and PostGIS, be aware that these are totally independent, separate extensions. The geometry associated with the nodes does not have to match at all with the underlying network topology. For example, the Euclidean distance between nodes is not necessarily the same as the cost associated with the edge connecting those nodes (but it can be the result of the computation of such a distance).\n\n\n\n\n\n\n\n\nYour Turn\n\n\n\n\nCreate an edge table called myedge and a node table called mynode. Remember to set the primary key on each table!\nFill your myedge and mynode tables with data corresponding to the network in the picture below. HINT: Refer back to Practical 6 if you need a reminder on how to insert spatial data into a table.\nVisualise your node table in QGIS.\nVisualise your edge table in QGIS. HINT: Use the QGIS DB Manager to write an SQL query that builds the edge geometries on-the-fly based on the node geometries. You will need to join your edge table to your node table - not once but twice. Look up an appropriate PostGIS function for constructing LineStrings from points.\n\n\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\nSQL solution for question 1:\nCREATE TABLE myedge (\n  edge_id integer NOT NULL,\n  source integer NOT NULL,\n  target integer NOT NULL,\n  PRIMARY KEY (edge_id)\n);\nCREATE TABLE mynode (\n  node_id integer NOT NULL,\n  geom geometry(Point) NOT NULL,\n  PRIMARY KEY (node_id)\n);\n-- Note, this network is not in any known SRS, so we do not specify an SRID for the `geom` column\nSQL solution for question 2:\nINSERT INTO myedge VALUES (1, 1, 2);\nINSERT INTO myedge VALUES (2, 2, 3);\nINSERT INTO myedge VALUES (3, 3, 4);\n-- ... and so on, for all edges\n\nINSERT INTO mynode VALUES (1, 'POINT (2 0)'::geometry);\n-- alternatively:\nINSERT INTO mynode VALUES (1, ST_Point(2, 0));\n-- ... and so on, for all nodes\nSQL solution for question 4:\nSELECT ST_MakeLine(s.geom, t.geom)\nFROM myedge\n  INNER JOIN mynode AS s ON s.node_id = source\n  INNER JOIN mynode AS t ON t.node_id = target;\n\n\n\n\n\n\nDijkstra’s algorithm is the classic algorithm for finding the shortest path from one node to another. pgRouting includes the pgr_dijkstra function, allowing you to easily run this algorithm on your own network.\npgRouting functions have an unusual syntax. You need to pass an SQL SELECT query as a text parameter. This embedded query must return a defined set of columns with specific names in a certain order.\nFor example, the official documentation for pgr_dijkstra defines the “one-to-one” function signature as follows:\npgr_dijkstra(Edges SQL, start vid, end vid, [directed])\nThe parameters themselves are defined under the heading “Parameters”. The word vid stands for vertex id - this is what we have named node_id. The directed parameter is a boolean, directed:=true or directed:=false, dictating whether the network should be treated as a directed graph, where different forward and reverse costs apply depending on the direction in which the edge is traversededge.\nFurther down the page, under the heading “Edges SQL”, the required columns to be returned by the embedded SQL query are listed. They are id, source, target, cost, and the optional column reverse_cost.\nThus, a basic template for calling pgr_dijkstra would be as follows:\nSELECT seq, node, edge, cost, agg_cost\nFROM pgr_dijkstra(\n  'SELECT ... AS id, ... AS source, ... AS target, ... AS cost [, ... AS reverse_cost]\n  FROM edge_table',\n  start-node-id, end-node-id,\n  directed:=true ...or... directed:=false\n);\n\n\n\n\n\n\nYour Turn\n\n\n\nUse the query template above to find the shortest path from node 7 to node 10 in the network. Set the cost of every edge as 1.\n\n\nWhen you run the above query, you should get the following output:\n\n\n\nseq\nnode\nedge\ncost\nagg_cost\n\n\n\n\n1\n7\n6\n1\n0\n\n\n2\n5\n9\n1\n1\n\n\n3\n9\n11\n1\n2\n\n\n4\n10\n-1\n0\n3\n\n\n\nLook at the table and the network above. Can you work out what the answer to your query means?\nWhen working with spatial networks, the cost of an edge is normally related in some way to the length of that edge. Let’s construct the geometry of each edge in the network, and repeat the above problem using the length of each edge as its cost.\n\n\n\n\n\n\nYour Turn\n\n\n\n\nCreate a view of the edge table that includes a dynamically-generated edge geometry column. Use the following SQL code:\n\nCREATE VIEW myedge_with_geom AS\nSELECT myedge.*, ST_MakeLine(s.geom, t.geom) AS geom\nFROM myedge\n  INNER JOIN mynode AS s ON s.node_id = source\n  INNER JOIN mynode AS t ON t.node_id = target;\nInspect the contents of this view using SELECT * FROM myedge_with_geom.\n\nFind the shortest path from node 7 to node 10, where the cost is the length (ST_Length) of each edge. Use the myedge_with_geom view.\nRerun the query between several different pairs of nodes, including 7 and 9, 11 and 3, 4 and 12. Each time check the answer carefully to make sure it accords with what you expected. If it doesn’t, then investigate and rectify the problem.\nNow adapt your query to compute only the total cost of each shortest path. Then change it again to list only the path itself, in terms of the sequence of nodes followed.\nRun the shortest path query between nodes 13 and 10, and from 6 to 16. Is the answer what you expected? Understand what the correct answer should be and why you get that answer.\nSwitch the cost of the edge from nodes 2 to 3 to -1. Now find the shortest route from nodes 1 to 3. What do you notice? What does cost -1 mean? HINT: To change the cost, use a CASE statement for the cost component of the embedded SQL query.\nNow find the shortest route from 3 to 1, but with reverse edge costs enabled.\n\n\n\n\n\n\nAlthough Dijkstra’s algorithm does not require any knowledge of the geometry of the network, the A* algorithm does. (Why? Read the documentation, and think about this.)\n\n\n\n\n\n\nYour Turn\n\n\n\nRun the following A* query using the following query template:\nSELECT seq, node, edge, cost\nFROM pgr_astar(\n  'SELECT id, source, target, ... AS cost, ... AS x1, ... AS x2, ... AS y1, ... AS y2\n   FROM edge_table',\n  1, 5\n);\nNote that even though the geometry of the edge end nodes is required for A*, this is not structured as a geometry data type. Work out how to add geometry to the edges using the geom column.\n\n\n\n\n\n\nTry the following challenges:\n\n\n\n\n\n\nYour Turn\n\n\n\n\nCompute the shortest paths from node 3 to both nodes 1 and 10 in one step using a single pass of the pgr_dijkstra function.\nCompute using an all-pairs shortest path algorithm (e.g., pgr_floydWarshall) the costs for paths between every pair of nodes in the network. (And check this carefully. What do you notice?)\nUse the \\(k\\)-shortest paths algorithm to compute the three shortest paths between nodes 11 and 1. HINT: Look for an appropriate function in the PostGIS documentation.\nNow work out how to display the shortest path generated by one of your queries in QGIS. The following query suggestion may assist: \n\n\n\n\n\n\nThere is a small portion of a real road network, the network around the University of Melbourne, included in the spatial schema, tables spatial.carlton_edges and spatial.carlton_nodes. You can apply the skills you now have to routing in this real road network.\nHave a look at the structure of these tables, and load the data into QGIS to view it. Selecting a suitable origin and destination node, and adapt the routing examples you’ve already encountered to find the shortest path between those two locations. Note that the routing itself may be a little slower as networks become larger. Use the techniques you developed above to display the shortest path in QGIS.\nNote on pgr_createTopology: You may notice in some documentation there is a function pgr_createTopology that is often used on a raw network to find intersections between edges and build the network topology from those intersections. You can experiment with it to create a topology of any network you import. It creates the edge table for you. See the scripts attached to this practical, above.\n\n\n\n\n\n\npgr_createTopology\n\n\n\n“pgr_createTopology” is a pgRouting function that prepares a network dataset for routing by building a topology (nodes and edges) from a set of geometries (linear features like roads, railways, etc.). The signature of the function is as follows:\npgr_createTopology(\n    edge_table text,    --Name of the table containing linear data (e.g., us_interstates)\n    tolerance float8,   --Snapping tolerance \n    the_geom text,        --Name of the geometry column in the linear data (e.g., geom)\n    id text,                  --Unique identifier column for edges\n    source text DEFAULT 'source',   --The new column that will hold start node IDs\n    target text DEFAULT 'target',   --The new columns that will hold end nodes IDs\n    clean boolean DEFAULT false       --If true, deletes old source/target values\n)\nTo create a topology for a linear feature (e.g., us_interstates), you first need to add the source, target, and edge_id columns, and then execute the topology creation function as follows:\n-- Create a copy of the linear feature in my schema\nCREATE TABLE userName.us_interstates as (SELECT * FROM spatial.us_interstates)\n\n-- Add 'source' and 'target' columns; integer type\nALTER TABLE userName.us_interstates ADD COLUMN 'source' integer\nALTER TABLE userName.us_interstates ADD COLUMN 'target' integer\n\n-- Add 'edge_id' column; integer type and unique constraint\nALTER TABLE userName.us_interstates ADD COLUMN edge_id serial unique\n\n-- Run topology function\nSELECT pgr_createTopology('userName.us_interstates', 0.00001, 'geom', 'edge_id')\nWhen pgr_createTopology is executed (with OK result), the source and target columns of the edge table are automatically populated with node IDs, and a corresponding vertices table named userName.tableName_vertices_pgr is generated. This vertices table stores the unique nodes of the network and serves as a reference for graph traversal. Once the topology is established, the full suite of pgRouting functions (e.g., pgr_dijkstra for shortest path analysis) can be applied to perform network analysis.\nNotes:\n\nThe source and target columns must be of an integer data type, as they represent the IDs of the nodes in the network graph.\nThe values of the source and target columns are automatically populated during topology creation by pgr_createTopology.\nThe edge_id column must be of an integer data type (e.g., INTEGER, SERIAL), and have a UNIQUE constraint, as it serves as the unique identifier of the edges, preventing duplicate records.\nUnlike source and target, the values of the edge_id column are not generated automatically during topology creation and must exist beforehand. Therefore, defining it as a SERIAL (auto-incrementing integer) is strongly recommended.\nSnapping tolerance is the distance threshold used when creating a topology to decide whether two vertices (line endpoints) should be treated as the same node.\n\n\n\n\n\n\n\nNetwork models and their representations\npgRouting Reference Manual\npgRouting Workshop\nUnderstanding Cost Arguments for pgRouting"
  },
  {
    "objectID": "P8_network.html#introduction-to-networks-and-pgrouting",
    "href": "P8_network.html#introduction-to-networks-and-pgrouting",
    "title": "[P8] Network analysis",
    "section": "",
    "text": "A network is a collection of objects linked into a structure. The connected (topological) structure of the network is typically represented by a set of nodes, as well as a set of edges (links) which represent connectivity between pairs of nodes. Edges in the network may be directed or undirected.\nA network may capture, for instance, the fabric of streets or railways connecting houses, suburbs and cities.\nTo practice network analysis inside our PostgreSQL database, we will be using pgRouting. This PostgreSQL extension provides a collection of algorithms for solving network analysis problems, including traversal, routing and accessibility analysis.\n\n\n\n\n\n\nNote\n\n\n\nA set of SQL queries of interest enabling to demonstrate how you build a network topology in PGRouting, a script is here: Network analysis.\n\n\n\n\nThe official documentation for pgRouting lists all available functions and describes how they work. The material is very rough and sometimes difficult to understand, however, it should still give you a general idea of what to do.\nMake sure you are reading the documentation for the correct version, as pgRouting is under active development. To check the pgRouting version on Wammawatcha, run the following SQL query:\nSELECT pgr_version();"
  },
  {
    "objectID": "P8_network.html#simple-network-analysis",
    "href": "P8_network.html#simple-network-analysis",
    "title": "[P8] Network analysis",
    "section": "",
    "text": "In this section, you will:\n\nlearn how to store a network in a relational DB, and\nlearn how to find shortest paths using pgRouting.\n\n\n\nAs discussed in this week’s lecture, one of the ways to store a network in a database is by forming an edge list.\nEach edge is written in terms of its two connected nodes. For example, an edge between node 9 and node 12 is written as 9,12.\nThe edge list can be implemented as a simple database table called an edge table. In this, each edge is given an id, and we store the source and target nodes of that edge:\n\n\n\nedge_id\nsource\ntarget\n\n\n\n\n15\n9\n12\n\n\n16\n4\n9\n\n\n…\n…\n…\n\n\n\nThe edge table can contain any other required attributes as additional columns. For instance, in a road network, the edge table could include “name” and “speed limit” attributes.\nOptionally, we can also create a node table to store the id and location (geom) of each node, and any other attributes such as node name:\n\n\n\nnode_id\ngeom\n\n\n\n\n1\nPOINT (2 0)\n\n\n2\nPOINT (2 1)\n\n\n…\n…\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAlthough we are mixing pgRouting and PostGIS, be aware that these are totally independent, separate extensions. The geometry associated with the nodes does not have to match at all with the underlying network topology. For example, the Euclidean distance between nodes is not necessarily the same as the cost associated with the edge connecting those nodes (but it can be the result of the computation of such a distance).\n\n\n\n\n\n\n\n\nYour Turn\n\n\n\n\nCreate an edge table called myedge and a node table called mynode. Remember to set the primary key on each table!\nFill your myedge and mynode tables with data corresponding to the network in the picture below. HINT: Refer back to Practical 6 if you need a reminder on how to insert spatial data into a table.\nVisualise your node table in QGIS.\nVisualise your edge table in QGIS. HINT: Use the QGIS DB Manager to write an SQL query that builds the edge geometries on-the-fly based on the node geometries. You will need to join your edge table to your node table - not once but twice. Look up an appropriate PostGIS function for constructing LineStrings from points.\n\n\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\nSQL solution for question 1:\nCREATE TABLE myedge (\n  edge_id integer NOT NULL,\n  source integer NOT NULL,\n  target integer NOT NULL,\n  PRIMARY KEY (edge_id)\n);\nCREATE TABLE mynode (\n  node_id integer NOT NULL,\n  geom geometry(Point) NOT NULL,\n  PRIMARY KEY (node_id)\n);\n-- Note, this network is not in any known SRS, so we do not specify an SRID for the `geom` column\nSQL solution for question 2:\nINSERT INTO myedge VALUES (1, 1, 2);\nINSERT INTO myedge VALUES (2, 2, 3);\nINSERT INTO myedge VALUES (3, 3, 4);\n-- ... and so on, for all edges\n\nINSERT INTO mynode VALUES (1, 'POINT (2 0)'::geometry);\n-- alternatively:\nINSERT INTO mynode VALUES (1, ST_Point(2, 0));\n-- ... and so on, for all nodes\nSQL solution for question 4:\nSELECT ST_MakeLine(s.geom, t.geom)\nFROM myedge\n  INNER JOIN mynode AS s ON s.node_id = source\n  INNER JOIN mynode AS t ON t.node_id = target;\n\n\n\n\n\n\nDijkstra’s algorithm is the classic algorithm for finding the shortest path from one node to another. pgRouting includes the pgr_dijkstra function, allowing you to easily run this algorithm on your own network.\npgRouting functions have an unusual syntax. You need to pass an SQL SELECT query as a text parameter. This embedded query must return a defined set of columns with specific names in a certain order.\nFor example, the official documentation for pgr_dijkstra defines the “one-to-one” function signature as follows:\npgr_dijkstra(Edges SQL, start vid, end vid, [directed])\nThe parameters themselves are defined under the heading “Parameters”. The word vid stands for vertex id - this is what we have named node_id. The directed parameter is a boolean, directed:=true or directed:=false, dictating whether the network should be treated as a directed graph, where different forward and reverse costs apply depending on the direction in which the edge is traversededge.\nFurther down the page, under the heading “Edges SQL”, the required columns to be returned by the embedded SQL query are listed. They are id, source, target, cost, and the optional column reverse_cost.\nThus, a basic template for calling pgr_dijkstra would be as follows:\nSELECT seq, node, edge, cost, agg_cost\nFROM pgr_dijkstra(\n  'SELECT ... AS id, ... AS source, ... AS target, ... AS cost [, ... AS reverse_cost]\n  FROM edge_table',\n  start-node-id, end-node-id,\n  directed:=true ...or... directed:=false\n);\n\n\n\n\n\n\nYour Turn\n\n\n\nUse the query template above to find the shortest path from node 7 to node 10 in the network. Set the cost of every edge as 1.\n\n\nWhen you run the above query, you should get the following output:\n\n\n\nseq\nnode\nedge\ncost\nagg_cost\n\n\n\n\n1\n7\n6\n1\n0\n\n\n2\n5\n9\n1\n1\n\n\n3\n9\n11\n1\n2\n\n\n4\n10\n-1\n0\n3\n\n\n\nLook at the table and the network above. Can you work out what the answer to your query means?\nWhen working with spatial networks, the cost of an edge is normally related in some way to the length of that edge. Let’s construct the geometry of each edge in the network, and repeat the above problem using the length of each edge as its cost.\n\n\n\n\n\n\nYour Turn\n\n\n\n\nCreate a view of the edge table that includes a dynamically-generated edge geometry column. Use the following SQL code:\n\nCREATE VIEW myedge_with_geom AS\nSELECT myedge.*, ST_MakeLine(s.geom, t.geom) AS geom\nFROM myedge\n  INNER JOIN mynode AS s ON s.node_id = source\n  INNER JOIN mynode AS t ON t.node_id = target;\nInspect the contents of this view using SELECT * FROM myedge_with_geom.\n\nFind the shortest path from node 7 to node 10, where the cost is the length (ST_Length) of each edge. Use the myedge_with_geom view.\nRerun the query between several different pairs of nodes, including 7 and 9, 11 and 3, 4 and 12. Each time check the answer carefully to make sure it accords with what you expected. If it doesn’t, then investigate and rectify the problem.\nNow adapt your query to compute only the total cost of each shortest path. Then change it again to list only the path itself, in terms of the sequence of nodes followed.\nRun the shortest path query between nodes 13 and 10, and from 6 to 16. Is the answer what you expected? Understand what the correct answer should be and why you get that answer.\nSwitch the cost of the edge from nodes 2 to 3 to -1. Now find the shortest route from nodes 1 to 3. What do you notice? What does cost -1 mean? HINT: To change the cost, use a CASE statement for the cost component of the embedded SQL query.\nNow find the shortest route from 3 to 1, but with reverse edge costs enabled.\n\n\n\n\n\n\nAlthough Dijkstra’s algorithm does not require any knowledge of the geometry of the network, the A* algorithm does. (Why? Read the documentation, and think about this.)\n\n\n\n\n\n\nYour Turn\n\n\n\nRun the following A* query using the following query template:\nSELECT seq, node, edge, cost\nFROM pgr_astar(\n  'SELECT id, source, target, ... AS cost, ... AS x1, ... AS x2, ... AS y1, ... AS y2\n   FROM edge_table',\n  1, 5\n);\nNote that even though the geometry of the edge end nodes is required for A*, this is not structured as a geometry data type. Work out how to add geometry to the edges using the geom column."
  },
  {
    "objectID": "P8_network.html#advanced-routing",
    "href": "P8_network.html#advanced-routing",
    "title": "[P8] Network analysis",
    "section": "",
    "text": "Try the following challenges:\n\n\n\n\n\n\nYour Turn\n\n\n\n\nCompute the shortest paths from node 3 to both nodes 1 and 10 in one step using a single pass of the pgr_dijkstra function.\nCompute using an all-pairs shortest path algorithm (e.g., pgr_floydWarshall) the costs for paths between every pair of nodes in the network. (And check this carefully. What do you notice?)\nUse the \\(k\\)-shortest paths algorithm to compute the three shortest paths between nodes 11 and 1. HINT: Look for an appropriate function in the PostGIS documentation.\nNow work out how to display the shortest path generated by one of your queries in QGIS. The following query suggestion may assist:"
  },
  {
    "objectID": "P8_network.html#working-with-real-networks",
    "href": "P8_network.html#working-with-real-networks",
    "title": "[P8] Network analysis",
    "section": "",
    "text": "There is a small portion of a real road network, the network around the University of Melbourne, included in the spatial schema, tables spatial.carlton_edges and spatial.carlton_nodes. You can apply the skills you now have to routing in this real road network.\nHave a look at the structure of these tables, and load the data into QGIS to view it. Selecting a suitable origin and destination node, and adapt the routing examples you’ve already encountered to find the shortest path between those two locations. Note that the routing itself may be a little slower as networks become larger. Use the techniques you developed above to display the shortest path in QGIS.\nNote on pgr_createTopology: You may notice in some documentation there is a function pgr_createTopology that is often used on a raw network to find intersections between edges and build the network topology from those intersections. You can experiment with it to create a topology of any network you import. It creates the edge table for you. See the scripts attached to this practical, above.\n\n\n\n\n\n\npgr_createTopology\n\n\n\n“pgr_createTopology” is a pgRouting function that prepares a network dataset for routing by building a topology (nodes and edges) from a set of geometries (linear features like roads, railways, etc.). The signature of the function is as follows:\npgr_createTopology(\n    edge_table text,    --Name of the table containing linear data (e.g., us_interstates)\n    tolerance float8,   --Snapping tolerance \n    the_geom text,        --Name of the geometry column in the linear data (e.g., geom)\n    id text,                  --Unique identifier column for edges\n    source text DEFAULT 'source',   --The new column that will hold start node IDs\n    target text DEFAULT 'target',   --The new columns that will hold end nodes IDs\n    clean boolean DEFAULT false       --If true, deletes old source/target values\n)\nTo create a topology for a linear feature (e.g., us_interstates), you first need to add the source, target, and edge_id columns, and then execute the topology creation function as follows:\n-- Create a copy of the linear feature in my schema\nCREATE TABLE userName.us_interstates as (SELECT * FROM spatial.us_interstates)\n\n-- Add 'source' and 'target' columns; integer type\nALTER TABLE userName.us_interstates ADD COLUMN 'source' integer\nALTER TABLE userName.us_interstates ADD COLUMN 'target' integer\n\n-- Add 'edge_id' column; integer type and unique constraint\nALTER TABLE userName.us_interstates ADD COLUMN edge_id serial unique\n\n-- Run topology function\nSELECT pgr_createTopology('userName.us_interstates', 0.00001, 'geom', 'edge_id')\nWhen pgr_createTopology is executed (with OK result), the source and target columns of the edge table are automatically populated with node IDs, and a corresponding vertices table named userName.tableName_vertices_pgr is generated. This vertices table stores the unique nodes of the network and serves as a reference for graph traversal. Once the topology is established, the full suite of pgRouting functions (e.g., pgr_dijkstra for shortest path analysis) can be applied to perform network analysis.\nNotes:\n\nThe source and target columns must be of an integer data type, as they represent the IDs of the nodes in the network graph.\nThe values of the source and target columns are automatically populated during topology creation by pgr_createTopology.\nThe edge_id column must be of an integer data type (e.g., INTEGER, SERIAL), and have a UNIQUE constraint, as it serves as the unique identifier of the edges, preventing duplicate records.\nUnlike source and target, the values of the edge_id column are not generated automatically during topology creation and must exist beforehand. Therefore, defining it as a SERIAL (auto-incrementing integer) is strongly recommended.\nSnapping tolerance is the distance threshold used when creating a topology to decide whether two vertices (line endpoints) should be treated as the same node."
  },
  {
    "objectID": "P8_network.html#resources",
    "href": "P8_network.html#resources",
    "title": "[P8] Network analysis",
    "section": "",
    "text": "Network models and their representations\npgRouting Reference Manual\npgRouting Workshop\nUnderstanding Cost Arguments for pgRouting"
  },
  {
    "objectID": "P4_logical.html",
    "href": "P4_logical.html",
    "title": "[P4] Logical design",
    "section": "",
    "text": "In last week’s practical class, you conducted requirements analysis and conceptual design for a simple company scenario. Now you can progress to a refinement.\nIn the logical step, you explicitly consider the target type of DBMS (database management system) – in this case, a relational DBMS. You model your data storage structures (relation schemas) in a manner that supports all the requirements for data integrity maintenance.\n\n\nIn contrast to conceptual design, logical design is much more of a science than an art.\nIn fact, the process can be broken down into a kind of algorithm, which will give good results if you have done your conceptual design properly and thoroughly.\n\nConvert entities to relations (tables).\n\n\nEmployee\n\n\nConvert attributes to columns.\n\nAlso identify the data type for each column.\nIf a column must always have a value for every row of the table, mark it as “NOT NULL” (a special kind of domain constraint).\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text …\n\n\nIf the table already has a clear identifying attribute(s), make it (them) the primary key (underlined). Otherwise add a surrogate key.\n\nRemember to impose the entity integrity constraint – primary keys can never be null.\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text …\n\n\nResolve relationships by adding foreign keys as described in the lecture.\n\nFor an M:N relationship, create an associative entity, a new linking table that contains foreign keys pointing to the tables participating in the relationship.\nTotal participation constraints become NOT NULL constraints on the foreign key.\n\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text departmentID integer NOT NULL …\n\n\n\n\n\n\n\n\n\n\nDepartment departmentID integer NOT NULL …\n\n\n\nPlace relationship attributes in the same table as the foreign key, or in the associative entity if applicable.\nNormalise your tables:\n\n1NF - see note below about multivalued attributes\nTables should already satisfy 2NF and 3NF if you created a clean conceptual model\n\nIdentify attributes that are spatial data types, and decide as much as possible on the data type (vector, raster), types of geometries (point, line, polygon, …) and other properties (dimensionality, Spatial Reference System). Some of this will only become clear once you start sourcing data, possibly after this stage of the process.\nConsider any constraints that you have not been able to implement in the logical model. Identify where you may need to maintain data integrity using triggers. Try to minimise their use. Decide if the trigger is run on INSERT, UPDATE, or DELETE of a record. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required.\n\n\n\n\n\n\n\ngeometry data type\n\n\n\n\nIn database design, spatial data cannot be treated as ordinary strings or numbers (conventional attributes) because it carries additional semantics: location, shape, and the spatial reference system identifier (SRID). Without spatial awareness, the database cannot recognise whether the data represents a POINT, LINE, or POLYGON, nor can it identify the coordinate reference system (CRS) in use. Moreover, if spatial data is stored as plain text or numeric values, spatial functions (useful for a wide range of spatial analysis and querying tasks such as computing distances and checking overlaps) cannot be applied.\nTo overcome these limitations, PostGIS introduces specialised data types for storing spatial data. The most used are the geometry and geography data types for vectors (POINTS, LINES, or POLYGONS). A geometry/geography column stores the spatial representation of an object in a way that PostgreSQL and PostGIS understand. When a geometry/geography column is defined, it carries with it the shape, the coordinates of the vertices, and the CRS identified by its SRID. Hence, geometrical and topological queries can be easily applied.\nHowever, the value of a geometry/geography column is in Well-Known Binary (WKB) format which is useful to read geometry but not easily interpretable by humans. In this regard, to find out basic but foundational information about geometry/geography columns (e.g., geometry type, coordinates of vertices, and SRID), you can use the functions GeometryType, ST_AsText, and ST_SRID as shown below for us_cities table:\n\nSELECT  location,                -- Returns the Well-Known Binary (WKB) representation of the geometry/geography\n        GeometryType(location),  -- Returns the type of the geometry as a string. Eg: 'LINESTRING', 'MULTIPOINT', etc.\n        ST_AsText(location),     -- Returns the Well-Known Text (WKT) representation of the geometry/geography\n        ST_SRID(location)        -- Returns the spatial reference identifier\nFROM spatial.us_cities;\n\nBy defining a geometry/geography column, the column’s data type will be USER-DEFINED and the column’s udt_name will be geometry or geography in PostgreSQL. USER-DEFINED means the column uses a custom data type created by an extension (e.g., PostGIS) or user rather than a built-in SQL type. udt_name tells us the actual geometry data type used in the column. The following query shows how to find out data type and udt_name oof the columns in the victoria_police_stations table:\n\nSELECT table_name, column_name, data_type, udt_name\nFROM information_schema.columns\nWHERE table_schema = 'spatial' AND table_name = 'victoria_police_stations';\n\nWhen designing conceptual and logical data models, it is important to distinguish between descriptive attributes (e.g., name, ID) and spatial attributes (geometry). For spatial entities, these should be mapped into database structures that accurately represent both their descriptive and spatial characteristics. The following example demonstrates how to create a table to achieve this:\n\n-- Example: Creating a spatial table in PostGIS\nCREATE TABLE user_schema.land_parcels (\n    parcel_id SERIAL PRIMARY KEY,          -- Descriptive attribute\n    owner_name VARCHAR(100),               -- Descriptive attribute\n    land_use   VARCHAR(50),                -- Descriptive attribute\n    area_m2    NUMERIC,                    -- Descriptive attribute\n    geom       geometry(Polygon, 7855)     -- Spatial attribute (Polygon, SRID 7855 = GDA2020 / MGA Zone 55)\n);\n\n-- Add a spatial index to speed up queries\nCREATE INDEX parcels_geom_idx\n    ON user_schema.land_parcels\n    USING GIST (geom);\n\n\n\n\n\n\n\n\nMultivalued, composite and derived attributes\n\n\n\nMultivalued, composite and derived attributes are an awkward fit for the traditional table-based model of a relational database. First normal form (1NF) requires that each “cell” of a table contains a single atomic value.\nIf you have studied other database subjects, you might have learned to resolve these attributes like this:\n\nResolve a multivalued attribute by splitting it into a separate table, associated to the original table with a one-to-many identifying relationship.\nResolve a composite attribute by simply adding its component parts to the table as individual columns.\nRemove derived attributes from the model, as they can be handled in your application layer.\n\nHowever, Postgres offers additional data types which allow us to store multiple pieces of data in a single field, in a way that is understood by the database query engine.\nDespite technically violating 1NF, these storage methods can nonetheless be very useful. Here is a modern perspective on the above recipe:\n\nMultivalued attributes could be stored using an Array data type (non-spatial), or as Multi* or GeometryCollection geometry columns (spatial).\nComposite attributes could, in some situations, be stored using the powerful jsonb data type.\nDerived attributes can be resolved as generated columns, stored procedures, triggers, or simply removed entirely. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required.\n\n\n\n\n\n\n\n\n\n\n\n\nYour Turn\n\n\n\nStarting from the conceptual design you completed in last week’s practical, prepare a logical design for the employee/department/project database scenario.\n\n\nFor the expression of the model, you can use any drawing technique you wish:\n\npen and paper;\na diagramming tool such as draw.io\na dedicated ER modelling tool, such as the ERD Tool in PGAdmin https://www.pgadmin.org/docs/pgadmin4/development/erd_tool.html. This uses a different notation than the one used previously for conceptual modelling – this is part of the logical design step, and ties the design of your tables to the creation of table schemas.\n\n\n\n\nYou are expected to present a logical design as part of Assignment 2. It will help you to think of other aspects of the project (look at all the project specification as well Assignments 4 and 5) as some aspects of the logical design would benefit from knowledge/anticipation of subsequent steps.\nFor the rest of the session, continue working on your group’s conceptual model for Assignment 2. Begin the logical model when you think you have completed your conceptual model."
  },
  {
    "objectID": "P4_logical.html#from-conceptual-to-logical-design",
    "href": "P4_logical.html#from-conceptual-to-logical-design",
    "title": "[P4] Logical design",
    "section": "",
    "text": "In contrast to conceptual design, logical design is much more of a science than an art.\nIn fact, the process can be broken down into a kind of algorithm, which will give good results if you have done your conceptual design properly and thoroughly.\n\nConvert entities to relations (tables).\n\n\nEmployee\n\n\nConvert attributes to columns.\n\nAlso identify the data type for each column.\nIf a column must always have a value for every row of the table, mark it as “NOT NULL” (a special kind of domain constraint).\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text …\n\n\nIf the table already has a clear identifying attribute(s), make it (them) the primary key (underlined). Otherwise add a surrogate key.\n\nRemember to impose the entity integrity constraint – primary keys can never be null.\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text …\n\n\nResolve relationships by adding foreign keys as described in the lecture.\n\nFor an M:N relationship, create an associative entity, a new linking table that contains foreign keys pointing to the tables participating in the relationship.\nTotal participation constraints become NOT NULL constraints on the foreign key.\n\n\nEmployee employeeID integer NOT NULL name text NOT NULL address text departmentID integer NOT NULL …\n\n\n\n\n\n\n\n\n\n\nDepartment departmentID integer NOT NULL …\n\n\n\nPlace relationship attributes in the same table as the foreign key, or in the associative entity if applicable.\nNormalise your tables:\n\n1NF - see note below about multivalued attributes\nTables should already satisfy 2NF and 3NF if you created a clean conceptual model\n\nIdentify attributes that are spatial data types, and decide as much as possible on the data type (vector, raster), types of geometries (point, line, polygon, …) and other properties (dimensionality, Spatial Reference System). Some of this will only become clear once you start sourcing data, possibly after this stage of the process.\nConsider any constraints that you have not been able to implement in the logical model. Identify where you may need to maintain data integrity using triggers. Try to minimise their use. Decide if the trigger is run on INSERT, UPDATE, or DELETE of a record. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required.\n\n\n\n\n\n\n\ngeometry data type\n\n\n\n\nIn database design, spatial data cannot be treated as ordinary strings or numbers (conventional attributes) because it carries additional semantics: location, shape, and the spatial reference system identifier (SRID). Without spatial awareness, the database cannot recognise whether the data represents a POINT, LINE, or POLYGON, nor can it identify the coordinate reference system (CRS) in use. Moreover, if spatial data is stored as plain text or numeric values, spatial functions (useful for a wide range of spatial analysis and querying tasks such as computing distances and checking overlaps) cannot be applied.\nTo overcome these limitations, PostGIS introduces specialised data types for storing spatial data. The most used are the geometry and geography data types for vectors (POINTS, LINES, or POLYGONS). A geometry/geography column stores the spatial representation of an object in a way that PostgreSQL and PostGIS understand. When a geometry/geography column is defined, it carries with it the shape, the coordinates of the vertices, and the CRS identified by its SRID. Hence, geometrical and topological queries can be easily applied.\nHowever, the value of a geometry/geography column is in Well-Known Binary (WKB) format which is useful to read geometry but not easily interpretable by humans. In this regard, to find out basic but foundational information about geometry/geography columns (e.g., geometry type, coordinates of vertices, and SRID), you can use the functions GeometryType, ST_AsText, and ST_SRID as shown below for us_cities table:\n\nSELECT  location,                -- Returns the Well-Known Binary (WKB) representation of the geometry/geography\n        GeometryType(location),  -- Returns the type of the geometry as a string. Eg: 'LINESTRING', 'MULTIPOINT', etc.\n        ST_AsText(location),     -- Returns the Well-Known Text (WKT) representation of the geometry/geography\n        ST_SRID(location)        -- Returns the spatial reference identifier\nFROM spatial.us_cities;\n\nBy defining a geometry/geography column, the column’s data type will be USER-DEFINED and the column’s udt_name will be geometry or geography in PostgreSQL. USER-DEFINED means the column uses a custom data type created by an extension (e.g., PostGIS) or user rather than a built-in SQL type. udt_name tells us the actual geometry data type used in the column. The following query shows how to find out data type and udt_name oof the columns in the victoria_police_stations table:\n\nSELECT table_name, column_name, data_type, udt_name\nFROM information_schema.columns\nWHERE table_schema = 'spatial' AND table_name = 'victoria_police_stations';\n\nWhen designing conceptual and logical data models, it is important to distinguish between descriptive attributes (e.g., name, ID) and spatial attributes (geometry). For spatial entities, these should be mapped into database structures that accurately represent both their descriptive and spatial characteristics. The following example demonstrates how to create a table to achieve this:\n\n-- Example: Creating a spatial table in PostGIS\nCREATE TABLE user_schema.land_parcels (\n    parcel_id SERIAL PRIMARY KEY,          -- Descriptive attribute\n    owner_name VARCHAR(100),               -- Descriptive attribute\n    land_use   VARCHAR(50),                -- Descriptive attribute\n    area_m2    NUMERIC,                    -- Descriptive attribute\n    geom       geometry(Polygon, 7855)     -- Spatial attribute (Polygon, SRID 7855 = GDA2020 / MGA Zone 55)\n);\n\n-- Add a spatial index to speed up queries\nCREATE INDEX parcels_geom_idx\n    ON user_schema.land_parcels\n    USING GIST (geom);\n\n\n\n\n\n\n\n\nMultivalued, composite and derived attributes\n\n\n\nMultivalued, composite and derived attributes are an awkward fit for the traditional table-based model of a relational database. First normal form (1NF) requires that each “cell” of a table contains a single atomic value.\nIf you have studied other database subjects, you might have learned to resolve these attributes like this:\n\nResolve a multivalued attribute by splitting it into a separate table, associated to the original table with a one-to-many identifying relationship.\nResolve a composite attribute by simply adding its component parts to the table as individual columns.\nRemove derived attributes from the model, as they can be handled in your application layer.\n\nHowever, Postgres offers additional data types which allow us to store multiple pieces of data in a single field, in a way that is understood by the database query engine.\nDespite technically violating 1NF, these storage methods can nonetheless be very useful. Here is a modern perspective on the above recipe:\n\nMultivalued attributes could be stored using an Array data type (non-spatial), or as Multi* or GeometryCollection geometry columns (spatial).\nComposite attributes could, in some situations, be stored using the powerful jsonb data type.\nDerived attributes can be resolved as generated columns, stored procedures, triggers, or simply removed entirely. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required."
  },
  {
    "objectID": "P4_logical.html#the-simple-scenario",
    "href": "P4_logical.html#the-simple-scenario",
    "title": "[P4] Logical design",
    "section": "",
    "text": "Your Turn\n\n\n\nStarting from the conceptual design you completed in last week’s practical, prepare a logical design for the employee/department/project database scenario.\n\n\nFor the expression of the model, you can use any drawing technique you wish:\n\npen and paper;\na diagramming tool such as draw.io\na dedicated ER modelling tool, such as the ERD Tool in PGAdmin https://www.pgadmin.org/docs/pgadmin4/development/erd_tool.html. This uses a different notation than the one used previously for conceptual modelling – this is part of the logical design step, and ties the design of your tables to the creation of table schemas."
  },
  {
    "objectID": "P4_logical.html#the-project",
    "href": "P4_logical.html#the-project",
    "title": "[P4] Logical design",
    "section": "",
    "text": "You are expected to present a logical design as part of Assignment 2. It will help you to think of other aspects of the project (look at all the project specification as well Assignments 4 and 5) as some aspects of the logical design would benefit from knowledge/anticipation of subsequent steps.\nFor the rest of the session, continue working on your group’s conceptual model for Assignment 2. Begin the logical model when you think you have completed your conceptual model."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Abouttttttttttttttttttttttttt",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HamidSDMTestWeb",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "P6_geometrical.html",
    "href": "P6_geometrical.html",
    "title": "[P6] Geometrical queries",
    "section": "",
    "text": "This practical is the first in a series of four on spatial data retrieval, analysis and manipulation using PostgreSQL.\nObjectives of this practical:\n\nYou will be introduced to working with spatial data in an Object-Relational DBMS (PostGIS).\nYou will learn how to investigate basic spatial properties of a database’s spatial data.\nYou will perform simple geometric analysis on objects in the database.\nYou will store spatial data in the database.\n\n\n\n\n\n\n\nNote\n\n\n\nA set of SQL queries of interest enabling to demonstrate some of the content from lectures is also here: Intro to spatial sql and geometrical operations\n\n\n\n\n\n\n\n\nImportant\n\n\n\nMuch of the material in this practical does not make sense if you have not been following the lectures!\n\n\n\n\n\n\n\n\nTip\n\n\n\nAll functions starting with ST_ are documented at the PostGIS Reference. This will be a crucial reference for you in the next few weeks.\n\n\n\n\nYou can execute spatial SQL queries using any PostgreSQL client, including pgAdmin. However, QGIS makes it especially easy to visualise our query’s results.\nDuring today’s practical, your tutor will demonstrate how to use the QGIS DB Manager to run spatial queries and visualise the results on the map.\n\n\nSpatial information represented by vector data is stored using columns of a data type geometry.The entire stored record (row), associating n attributes with (typically) a single geometry column, is often called a feature.\nPostGIS and other DBMS allow you to store multiple geometry columns within one table (and this has all sorts of modeling advantages) but it may challenge the interaction with many traditional GIS.1\n\n\n\n\n\n\nYour Turn\n\n\n\nOpen pgAdmin, the QGIS DB Manager, or your preferred PostgreSQL querying tool of choice, and write SQL queries to answer the following questions:\n\nName all the tables in the spatial schema that contain spatial data. HINT: The geometry columns in PostGIS are listed as data type USER-DEFINED in the table information_schema.columns. Refer back to Practical 1b if you need a refresher.\nList the geometry type of each table in the spatial schema. HINT: The table (or rather, a view) geometry_columns (in the ‘public’ schema) is a little more informative about the geometry data types. Start with a SELECT * query on geometry_columns to see what data is available, then narrow it down to just the columns and rows required.\n\nIf you get stuck on these questions, the full SQL queries are in the “Answers” box below.\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\nQuery 1:\nSELECT DISTINCT table_name\nFROM information_schema.columns\nWHERE table_schema = 'spatial' AND data_type = 'USER-DEFINED'\nORDER BY table_name;\nQuery 2:\nSELECT f_table_name, type\nFROM geometry_columns\nWHERE f_table_schema = 'spatial'\nORDER BY f_table_name;\n\n\n\n\n\n\n\nWe will find out some basic information about the types of geometries, as well as the coordinate systems used to georeference (relate to the Earth) spatial objects. We will use the state of New York (us_states.state_abrv='NY') and other US states.\n\n\nOne of the most important pieces of information we need about a specific spatial object is what type of object it is (point, line, polygon, …).\nThis can be retrieved using the following query template, based on the PostGIS function GeometryType:\nSELECT GeometryType(geom)\nFROM spatial._______;\nWe can also find the Well-Known Text (WKT) representation of a geometry using the ST_AsText PostGIS function:\nSELECT ST_AsText(geom)\nFROM ...\n\n\n\n\n\n\nYour Turn\n\n\n\n\nIn the query you ran in the previous section, you may have noticed that some of the tables in the spatial schema, such as us_rivers and world_countries, had a defined geometry type of GEOMETRY. This means they can contain any geometry type. Use the GeometryType function to ascertain the geometry types that are actually contained within each of these tables. HINT: Use SELECT DISTINCT to remove duplicate values from your results.\nFind the WKT representation of the location of all McDonald’s restaurants in the us_restaurants table. HINT: Because ' has a special meaning in SQL, you need to write the restaurant name as 'MCDONALD''S' with a double apostrophe.\n\n\n\n\n\n\nWe need to understand the meaning of the coordinate values encoding vertices of geometries. Without that, we are unable to interpret, e.g., the meaasurement of spatial properties such as areas and distances.\nThe SRID is a code specifying in what coordinate system spatial data are stored. Most commonly, these codes come from the EPSG database (this is often referred to as authority). This database is stored in the spatial_ref_sys table. Users can extend this table - just do not overwrite any existing SRIDs! Thus, you can create your own IDs, with your own authority, and specify a SRID with parameters you want.\n\n\n\n\n\n\nYour Turn\n\n\n\n\nFind out what coordinate system the geometries capturing the state of Georgia are stored in. Use the query template below:\n\nSELECT ST_SRID(geom)\nFROM spatial.us_states\nWHERE ...;\n\nThe previous query returned an SRID. Look up this SRID in the spatial_ref_sys table (note, this table is part of PostGIS and is not in the spatial schema):\n\nSELECT *\nFROM spatial_ref_sys\nWHERE srid = ____;\nCan you work out the name of this SRS, and whether it is a geographic (longitude/latitude) or projected SRS? HINT: Expand your view of the srtext and proj4text columns and see if you can spot any useful details.\n\nUse the resource at epsg.io to find out more about this SRS.\n\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\nThe SRS is WGS 84.\nThe row in the spatial_ref_sys table holds useful info:\n\nThe srtext value starts GEOGCS[\"WGS 84\",.... So it is a geographic coordinate system. The piece of text after the first [ is the SRS name. On this case it is “WGS 84”.\nThe proj4text value starts +proj=longlat, which also tells us it is a geographic coordinate system.\n\n\n\n\n\n\n\n\nOften, it is necessary to transform data (for instance, during the Extract-Transform-Load process), to correlate them with other data. This may involve complex transformations (see the lecture on projections and transformations).\nTwo concepts are important here: source SRS (given by SRID) and target SRS. Typically, for well stored data, a table will have geometries with an assigned SRID (as tested above). Then, this is your source SRID and you only need to specify what is the target SRID you want to transform into.\nTo transform geometries with an already assigned SRID to a target SRID:\nSELECT ST_Transform(geom, targetSRID)\nFROM table_name;\nSometimes geometry data lacks an assigned SRID. You then need to set it for the given geometries, before you can transform:\nSELECT ST_Transform(ST_SetSRID(geom, sourceSRID), targetSRID)\nFROM table_name;\nUnderstanding the difference between ST_SetSRID and ST_Transform is crucial. Read the ST_SetSRID documentation and note the difference - ST_SetSRID does not perform a transformation, it keeps the coordinates the same and merely overprints/adds the information about the used SRID. On the other hand, ST_Transform actually transforms the data itself.\n\n\n\n\n\n\nYour Turn\n\n\n\n\nWhat SRID are the geometries in the spatial.victoria_police_stations table in? Is this a geographic or projected coordinate system?\nUse the ST_AsText function to inspect the coordinates of each police station:\n\nSELECT name, ST_AsText(geom)\nFROM spatial.victoria_police_stations;\n\nTransform the coordinates of 'Branxholme Police Station' to longitude/latitudes and display these coordinates using ST_AsText.\nSearch up this police station on Google Maps and right-click on the location on the map – do you see the same coordinates?\n\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\nRemember to query the spatial_ref_sys table or look up epsg.io to find out details about an SRID (EPSG code).\nThe longitude/latitude of Branxholme Police Station is 141.798761°E 37.858406°S.\n\n\n\n\n\n\n\nPostGIS can be told to intepret geometries stored in a geographic SRS, such as EPSG:4326, as geographies. It has to be explicitly told to do so! The table will then register its column in the geography_columns, see above. PostGIS automatically applies precise spheroidal equations to compute areas, distances and angles on geographies.\nThis implies:\n- A more limited set of functions\n- More accurate\n- More computationally expensive\nUsers can also tell PostGIS to interpret a given geometry as a geography, by casting: mygeom::geography\n\n\n\n\nIn addition to coordinates, we can find out a variety of spatial information for our spatial data, by analysing the geometries representing the records. These values do not have to be stored as attributes, but can be computed on the fly.\nTo work with the geometries in PostGIS, you have to provide a spatial function and its parameter as arguments of the SELECT statement.\n\n\nCalculate the area of a Polygon or MultiPolygon geometry like this:\nSELECT ST_Area(geometry_column)\nFROM ...;\n\n\n\n\n\n\nYour Turn\n\n\n\n\nFind the area of New York state. What are the units of your answer?\nLook up the documentation for ST_Area on the web. Note that the function accepts a second parameter, use_spheroid := true or use_spheroid := false. Investigate what this argument does and what difference it makes to your answer.\nWrite a query to list the names of the four largest US states by area. Return the results in descending order of area (largest first). Review the Basic SQL Practical if you need.\n\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\nThe land area of New York state is around 127,000 km².\nThe four largest US states, listed with the largest first, are Alaska, Texas, California and Montana.\n\n\n\n\n\n\n\nTwo related functions return the length for lines or the perimeter for polygons. The functions are ST_Length(geometry_column) and ST_Perimeter(geometry_column). Just as with ST_Area, these functions both accept the use_spheroid parameter.\n\n\n\n\n\n\nYour Turn\n\n\n\n\nFind the perimeter of New York state in kilometers.\nWhat is the total length of all the rivers (table us_rivers) that belong to the ‘Colorado’ system?\n\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\nThe perimeter of New York state is around 2,500 km.\nThe total length of rivers in the Colorado system is around 4,350 km.\n\n\n\n\n\n\n\nBounding boxes are an important concept in spatial data handling. They provide the extent of the object along the axes of the coordinate system.\nThe functions ST_XMax(geometry), ST_XMin(geometry), ST_YMax(geometry), and ST_YMin(geometry) return the coordinates of the constituent parts of the minimum bounding rectangle (MBR) of a geometry. The function ST_Envelope(geometry) also provides the MBR as a geometry itself.\n\n\n\n\n\n\nYour Turn\n\n\n\n\nFind the MBR of New York in two different ways:\n\nFirst, use the ST_XMax, ST_XMin, ST_YMax, ST_YMin functions.\nThen use the ST_Envelope function. Convert the geometry to the human-readable Well-Known Text (WKT) format using the ST_AsText function.\n\nWrite a single SQL statement to give the minimum and maximum latitude for each state. Label the columns in your statement name, maxlat, and minlat.\n\nHINT: Assign aliases to the outputs of the SELECT statement using AS:\nSELECT state AS name, \n       SomeFunction(parameters...) AS maxlat,\n       ...\nFROM ...;\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\n\n\nThe MBR of New York State\n\n\n\n\n\n\n\n\n\nYou will now define and create your own table with sample spatial data. At the end of the lab, don’t forget to remove the metadata entries, drop the table and indexes.\nIn this section, you will create a table petrolstation with spatial data in a column called location. The table will contain the coordinates of three “petrol stations”, with the following coordinates:\n\n\n\nName\nID\nPoint(lon, lat)\n\n\n\n\nBP\n1\n-0.3448, 51.5361\n\n\nShell\n2\n-0.3921, 51.5363\n\n\nEsso\n3\n-0.3712, 51.5324\n\n\n\nUse the following templates:\nINSERT INTO petrolstation VALUES (..., ST_GeomFromText('POINT(x1 x2)', 4326));\n\n\n\n\n\n\nYour Turn\n\n\n\n\nCreate the table. When creating a vector geometry column, you can simply specify the data type as geometry, which allows any type of vector data. Alternatively, you can optionally set a constraint on the column’s geometry type: geometry(Point) - or even on geometry type and SRID: geometry(Point, 4326).\nInsert the data into the table. Define geometries using the ST_GeomFromText PostGIS function. Alternatively, you can explore the functions ST_Point and ST_MakePoint. Read the PostGIS documentation, and experiment with alternative ways of creating geometries.\nVerify the creation of the table by selecting its records. Use the ST_AsText function to view the geometries.\nVisualise the spatial data in the table using QGIS. Where in the world are these petrol stations?\n\n\n\n\n\n\nNow we can perform some simple geometric analyses.\n\n\nThe distance between any geometry (point, line, or polygon) and a point can be determined using the function ST_Distance. Note that in the case of distance between a line or polygon and a point, the function retrieves the minimum distance.\nFor example, try the following query which will provide the distance in metres between two of the petrol stations.\nSELECT ST_Distance(a.location, b.location, use_spheroid:=true) \nFROM petrolstation a, petrolstation b \nWHERE a.name='BP' and b.name='Shell';\n\n\n\n\n\n\nYour Turn\n\n\n\n\nWrite a query to find the distances between all pairs of petrol stations.\nSelect the names of the 10 closest restaurants from the restaurant poi_id = 33625120(us_restaurants table).\n\n\n\nWe can also find places that are within a certain distance of each other using the ST_DWithin function. Try the following query, inserting a range of sensible values in place of the distance ___:\nSELECT *\nFROM petrolstation a, petrolstation b\nWHERE ST_DWithin(a.location, b.location, ___);\n\n\n\nA buffer creates a new geometry containing all the locations within a specified distance of a input geometry. Create buffers of 1 km around each of the petrol stations, using the following template:\nSELECT ST_Buffer(geometry_column, distance)\nFROM ...;\nAgain, beware of the units!\nWe can also create the centroid (center of gravity) for a polygonal shape using the following template:\nSELECT ST_Centroid(geometry) \nFROM ...;\n\n\n\n\n\n\nYour Turn\n\n\n\n\nFind the centroid of the buffer of 1000 m for the Shell petrol station. What do you notice about this centroid and why?\nUse QGIS to visualise 1000 m buffers around all the us_restaurants. Are there any parts of Washington, DC that are more than 1000 m away from a restaurant?\n\n\n\n\n\n\nSome geometries may be of type GeometryCollection or Multi..., when there are multiple member geometries. It is then convenient to check how many geometry parts are in a multi-geometry, and to access these parts, for instance separating multi-geometries into components.\nYou can form a GeometryCollection or Multi* geometry using ST_Collect:\nSELECT ST_Collect(geom)\nFROM ...\nNote this is an aggregate function (like SUM or AVG), so it will take many rows and return a single value.\nThe reverse operation – splitting a GeometryCollection out into its component parts – is done using ST_Dump:\nSELECT (ST_Dump(geom_coll)).geom\nFROM ...\nYou can explore the part of PostGIS documentation related to GeometryCollections.\n\n\n\n\n\n\nYour Turn\n\n\n\n\nUse the ST_Collect and ST_Area functions to calculate the total area of all US states. Compare this with the area of the United States geometry in the world_counties table.\nAccording to the data in the world_countries table, how many islands (individual polygons) is Australia made up of? Use ST_Dump in your SQL query to answer this question.\n\n\n\n\n\n\nLinear referencing deal with positioning along linear geometries (e.g., “where does this point fall along a road/river/rail?”). That is not just a geometric property (like area/perimeter), but a form of spatial analysis specific to linear data.\n\nST_LineLocatePoint function in PostGIS provides the fractional position of a point along a line. It returns a number between 0 and 1 (0 → start of the line, 1 → end of the line, and e.g., 0.25 → the point is 25% along the line from the start):\n\nSELECT ST_LineLocatePoint(line_geom, point_geom)\nFROM ...\n\nST_LineInterpolatePoint is a PostGIS function used in geometrical analysis to find an exact position of a point along a line at a specified fractional distance. It returns a POINT geometry at the specified fraction along the line:\n\nSELECT ST_LineInterpolatePoint(line_geometry, fraction)\nFROM ...\n\n\n\n\n\n\nYour Turn\n\n\n\n\nFor route 31 in the table spatial.ptv_bus_routes, what are the linear reference positions of bus stops (spatial.ptv_bus_stops) located within 50 metres of the route? Provide each stop’s fraction along the route and its distance in metres from the start of the route.\nUsing the results from the previous step, write a query to compute the exact coordinates of each bus stop along the route.\nVisualise the resulting bus stops and their positions along the route in QGIS.\n\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\nUse the following sql:\n\nSELECT \n    r.id AS route_id,\n    st.id AS stop_id,\n    ST_LineLocatePoint(ST_LineMerge(ST_Transform(r.geom, 7855)),\n                       ST_Transform(st.geom, 7855)) AS stop_position_fraction,\n    ST_LineLocatePoint(ST_LineMerge(ST_Transform(r.geom, 7855)),\n                       ST_Transform(st.geom, 7855)) *\n    ST_Length(ST_LineMerge(ST_Transform(r.geom, 7855))) AS stop_position_meters\nFROM spatial.ptv_bus_stops st\nJOIN spatial.ptv_bus_routes r\n   ON r.id = 31\nWHERE ST_DWithin(ST_Transform(st.geom, 7855), \n                 ST_Transform(r.geom, 7855), 50)  -- only stops within 50 meters of route 68\nORDER BY stop_position_meters, st.id;\n\nUse the following sql:\n\nSELECT\n    r.id AS route_id,\n    st.id AS stop_id,\n    ST_LineLocatePoint(\n        ST_LineMerge(ST_Transform(r.geom, 7855)),\n        ST_Transform(st.geom, 7855)\n    ) AS stop_position_fraction,\n    ST_LineInterpolatePoint(\n        ST_LineMerge(ST_Transform(r.geom, 7855)),\n        ST_LineLocatePoint(\n            ST_LineMerge(ST_Transform(r.geom, 7855)),\n            ST_Transform(st.geom, 7855)\n        )\n    ) AS interpolated_point\nFROM spatial.ptv_bus_stations st\nJOIN spatial.ptv_bus_routes r\n    ON r.id = 31\nWHERE ST_DWithin(\n        ST_Transform(st.geom, 7855),\n        ST_Transform(r.geom, 7855),\n        50\n    )\nORDER BY stop_position_fraction, st.id;\n\n\n\n\n\n\n\nOther than creating data by hand, there are other means of creating content. This may be by modifying/computing geometrical content based on the existing content of other tables (or even the same one), parsing content from textual sources (importing text with coordinates and parsing this into e.g., points through the same processes investigated above), or importing content from GIS tools, or through ETL (Extract-Transform-Load) processes.\nSome hints are below.\n\n\nData can be created from a join, based on other tables. Note that below, you could add a functions to the SQL statement geom = t2.geom, e.g., geom = ST(centroid(t2.geom). What would that do?\nUPDATE petrolstation as t1\nSET geom = t2.geom \nFROM otherschema.pois as t2\nWHERE t1.attribute1 = t2.attribute2;\n\n\n\n\nFrom a GIS: experiment with QGIS, and try to export/save data from a shapefile into the database. This is now as easy as establishing a connection to your database in the Browser panel, and dragging some layers of data (e.g., hand digitised, or from a shapefile or similar format) from the Layers panel into the schema. Of course, you can be more nuanced.\nFrom an ETL (extract-transform-load) tool, e.g., FME, GDAL.org/ogr2ogr (excellent command line conversion utility). You can experiment with the tool ogr2ogr which is part of the QGIS installation (it is what actually powers QGIS). This is one of the most powerful tools in geospatial.\n\n\n\n\n\n\n\nTip\n\n\n\nLearn more: A detailed set of instructions for various import means is here: https://postgis.net/workshops/en/postgis-intro/loading_data.html\n\n\n\n\n\n\n\nPostGIS documentation: https://postgis.net/documentation/"
  },
  {
    "objectID": "P6_geometrical.html#getting-started",
    "href": "P6_geometrical.html#getting-started",
    "title": "[P6] Geometrical queries",
    "section": "",
    "text": "You can execute spatial SQL queries using any PostgreSQL client, including pgAdmin. However, QGIS makes it especially easy to visualise our query’s results.\nDuring today’s practical, your tutor will demonstrate how to use the QGIS DB Manager to run spatial queries and visualise the results on the map.\n\n\nSpatial information represented by vector data is stored using columns of a data type geometry.The entire stored record (row), associating n attributes with (typically) a single geometry column, is often called a feature.\nPostGIS and other DBMS allow you to store multiple geometry columns within one table (and this has all sorts of modeling advantages) but it may challenge the interaction with many traditional GIS.1\n\n\n\n\n\n\nYour Turn\n\n\n\nOpen pgAdmin, the QGIS DB Manager, or your preferred PostgreSQL querying tool of choice, and write SQL queries to answer the following questions:\n\nName all the tables in the spatial schema that contain spatial data. HINT: The geometry columns in PostGIS are listed as data type USER-DEFINED in the table information_schema.columns. Refer back to Practical 1b if you need a refresher.\nList the geometry type of each table in the spatial schema. HINT: The table (or rather, a view) geometry_columns (in the ‘public’ schema) is a little more informative about the geometry data types. Start with a SELECT * query on geometry_columns to see what data is available, then narrow it down to just the columns and rows required.\n\nIf you get stuck on these questions, the full SQL queries are in the “Answers” box below.\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\nQuery 1:\nSELECT DISTINCT table_name\nFROM information_schema.columns\nWHERE table_schema = 'spatial' AND data_type = 'USER-DEFINED'\nORDER BY table_name;\nQuery 2:\nSELECT f_table_name, type\nFROM geometry_columns\nWHERE f_table_schema = 'spatial'\nORDER BY f_table_name;"
  },
  {
    "objectID": "P6_geometrical.html#information-about-geometries",
    "href": "P6_geometrical.html#information-about-geometries",
    "title": "[P6] Geometrical queries",
    "section": "",
    "text": "We will find out some basic information about the types of geometries, as well as the coordinate systems used to georeference (relate to the Earth) spatial objects. We will use the state of New York (us_states.state_abrv='NY') and other US states.\n\n\nOne of the most important pieces of information we need about a specific spatial object is what type of object it is (point, line, polygon, …).\nThis can be retrieved using the following query template, based on the PostGIS function GeometryType:\nSELECT GeometryType(geom)\nFROM spatial._______;\nWe can also find the Well-Known Text (WKT) representation of a geometry using the ST_AsText PostGIS function:\nSELECT ST_AsText(geom)\nFROM ...\n\n\n\n\n\n\nYour Turn\n\n\n\n\nIn the query you ran in the previous section, you may have noticed that some of the tables in the spatial schema, such as us_rivers and world_countries, had a defined geometry type of GEOMETRY. This means they can contain any geometry type. Use the GeometryType function to ascertain the geometry types that are actually contained within each of these tables. HINT: Use SELECT DISTINCT to remove duplicate values from your results.\nFind the WKT representation of the location of all McDonald’s restaurants in the us_restaurants table. HINT: Because ' has a special meaning in SQL, you need to write the restaurant name as 'MCDONALD''S' with a double apostrophe.\n\n\n\n\n\n\nWe need to understand the meaning of the coordinate values encoding vertices of geometries. Without that, we are unable to interpret, e.g., the meaasurement of spatial properties such as areas and distances.\nThe SRID is a code specifying in what coordinate system spatial data are stored. Most commonly, these codes come from the EPSG database (this is often referred to as authority). This database is stored in the spatial_ref_sys table. Users can extend this table - just do not overwrite any existing SRIDs! Thus, you can create your own IDs, with your own authority, and specify a SRID with parameters you want.\n\n\n\n\n\n\nYour Turn\n\n\n\n\nFind out what coordinate system the geometries capturing the state of Georgia are stored in. Use the query template below:\n\nSELECT ST_SRID(geom)\nFROM spatial.us_states\nWHERE ...;\n\nThe previous query returned an SRID. Look up this SRID in the spatial_ref_sys table (note, this table is part of PostGIS and is not in the spatial schema):\n\nSELECT *\nFROM spatial_ref_sys\nWHERE srid = ____;\nCan you work out the name of this SRS, and whether it is a geographic (longitude/latitude) or projected SRS? HINT: Expand your view of the srtext and proj4text columns and see if you can spot any useful details.\n\nUse the resource at epsg.io to find out more about this SRS.\n\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\nThe SRS is WGS 84.\nThe row in the spatial_ref_sys table holds useful info:\n\nThe srtext value starts GEOGCS[\"WGS 84\",.... So it is a geographic coordinate system. The piece of text after the first [ is the SRS name. On this case it is “WGS 84”.\nThe proj4text value starts +proj=longlat, which also tells us it is a geographic coordinate system.\n\n\n\n\n\n\n\n\nOften, it is necessary to transform data (for instance, during the Extract-Transform-Load process), to correlate them with other data. This may involve complex transformations (see the lecture on projections and transformations).\nTwo concepts are important here: source SRS (given by SRID) and target SRS. Typically, for well stored data, a table will have geometries with an assigned SRID (as tested above). Then, this is your source SRID and you only need to specify what is the target SRID you want to transform into.\nTo transform geometries with an already assigned SRID to a target SRID:\nSELECT ST_Transform(geom, targetSRID)\nFROM table_name;\nSometimes geometry data lacks an assigned SRID. You then need to set it for the given geometries, before you can transform:\nSELECT ST_Transform(ST_SetSRID(geom, sourceSRID), targetSRID)\nFROM table_name;\nUnderstanding the difference between ST_SetSRID and ST_Transform is crucial. Read the ST_SetSRID documentation and note the difference - ST_SetSRID does not perform a transformation, it keeps the coordinates the same and merely overprints/adds the information about the used SRID. On the other hand, ST_Transform actually transforms the data itself.\n\n\n\n\n\n\nYour Turn\n\n\n\n\nWhat SRID are the geometries in the spatial.victoria_police_stations table in? Is this a geographic or projected coordinate system?\nUse the ST_AsText function to inspect the coordinates of each police station:\n\nSELECT name, ST_AsText(geom)\nFROM spatial.victoria_police_stations;\n\nTransform the coordinates of 'Branxholme Police Station' to longitude/latitudes and display these coordinates using ST_AsText.\nSearch up this police station on Google Maps and right-click on the location on the map – do you see the same coordinates?\n\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\nRemember to query the spatial_ref_sys table or look up epsg.io to find out details about an SRID (EPSG code).\nThe longitude/latitude of Branxholme Police Station is 141.798761°E 37.858406°S.\n\n\n\n\n\n\n\nPostGIS can be told to intepret geometries stored in a geographic SRS, such as EPSG:4326, as geographies. It has to be explicitly told to do so! The table will then register its column in the geography_columns, see above. PostGIS automatically applies precise spheroidal equations to compute areas, distances and angles on geographies.\nThis implies:\n- A more limited set of functions\n- More accurate\n- More computationally expensive\nUsers can also tell PostGIS to interpret a given geometry as a geography, by casting: mygeom::geography"
  },
  {
    "objectID": "P6_geometrical.html#spatial-properties-of-geometries",
    "href": "P6_geometrical.html#spatial-properties-of-geometries",
    "title": "[P6] Geometrical queries",
    "section": "",
    "text": "In addition to coordinates, we can find out a variety of spatial information for our spatial data, by analysing the geometries representing the records. These values do not have to be stored as attributes, but can be computed on the fly.\nTo work with the geometries in PostGIS, you have to provide a spatial function and its parameter as arguments of the SELECT statement.\n\n\nCalculate the area of a Polygon or MultiPolygon geometry like this:\nSELECT ST_Area(geometry_column)\nFROM ...;\n\n\n\n\n\n\nYour Turn\n\n\n\n\nFind the area of New York state. What are the units of your answer?\nLook up the documentation for ST_Area on the web. Note that the function accepts a second parameter, use_spheroid := true or use_spheroid := false. Investigate what this argument does and what difference it makes to your answer.\nWrite a query to list the names of the four largest US states by area. Return the results in descending order of area (largest first). Review the Basic SQL Practical if you need.\n\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\nThe land area of New York state is around 127,000 km².\nThe four largest US states, listed with the largest first, are Alaska, Texas, California and Montana.\n\n\n\n\n\n\n\nTwo related functions return the length for lines or the perimeter for polygons. The functions are ST_Length(geometry_column) and ST_Perimeter(geometry_column). Just as with ST_Area, these functions both accept the use_spheroid parameter.\n\n\n\n\n\n\nYour Turn\n\n\n\n\nFind the perimeter of New York state in kilometers.\nWhat is the total length of all the rivers (table us_rivers) that belong to the ‘Colorado’ system?\n\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\nThe perimeter of New York state is around 2,500 km.\nThe total length of rivers in the Colorado system is around 4,350 km.\n\n\n\n\n\n\n\nBounding boxes are an important concept in spatial data handling. They provide the extent of the object along the axes of the coordinate system.\nThe functions ST_XMax(geometry), ST_XMin(geometry), ST_YMax(geometry), and ST_YMin(geometry) return the coordinates of the constituent parts of the minimum bounding rectangle (MBR) of a geometry. The function ST_Envelope(geometry) also provides the MBR as a geometry itself.\n\n\n\n\n\n\nYour Turn\n\n\n\n\nFind the MBR of New York in two different ways:\n\nFirst, use the ST_XMax, ST_XMin, ST_YMax, ST_YMin functions.\nThen use the ST_Envelope function. Convert the geometry to the human-readable Well-Known Text (WKT) format using the ST_AsText function.\n\nWrite a single SQL statement to give the minimum and maximum latitude for each state. Label the columns in your statement name, maxlat, and minlat.\n\nHINT: Assign aliases to the outputs of the SELECT statement using AS:\nSELECT state AS name, \n       SomeFunction(parameters...) AS maxlat,\n       ...\nFROM ...;\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\n\n\nThe MBR of New York State"
  },
  {
    "objectID": "P6_geometrical.html#spatial-data-storage",
    "href": "P6_geometrical.html#spatial-data-storage",
    "title": "[P6] Geometrical queries",
    "section": "",
    "text": "You will now define and create your own table with sample spatial data. At the end of the lab, don’t forget to remove the metadata entries, drop the table and indexes.\nIn this section, you will create a table petrolstation with spatial data in a column called location. The table will contain the coordinates of three “petrol stations”, with the following coordinates:\n\n\n\nName\nID\nPoint(lon, lat)\n\n\n\n\nBP\n1\n-0.3448, 51.5361\n\n\nShell\n2\n-0.3921, 51.5363\n\n\nEsso\n3\n-0.3712, 51.5324\n\n\n\nUse the following templates:\nINSERT INTO petrolstation VALUES (..., ST_GeomFromText('POINT(x1 x2)', 4326));\n\n\n\n\n\n\nYour Turn\n\n\n\n\nCreate the table. When creating a vector geometry column, you can simply specify the data type as geometry, which allows any type of vector data. Alternatively, you can optionally set a constraint on the column’s geometry type: geometry(Point) - or even on geometry type and SRID: geometry(Point, 4326).\nInsert the data into the table. Define geometries using the ST_GeomFromText PostGIS function. Alternatively, you can explore the functions ST_Point and ST_MakePoint. Read the PostGIS documentation, and experiment with alternative ways of creating geometries.\nVerify the creation of the table by selecting its records. Use the ST_AsText function to view the geometries.\nVisualise the spatial data in the table using QGIS. Where in the world are these petrol stations?"
  },
  {
    "objectID": "P6_geometrical.html#simple-geometric-analysis",
    "href": "P6_geometrical.html#simple-geometric-analysis",
    "title": "[P6] Geometrical queries",
    "section": "",
    "text": "Now we can perform some simple geometric analyses.\n\n\nThe distance between any geometry (point, line, or polygon) and a point can be determined using the function ST_Distance. Note that in the case of distance between a line or polygon and a point, the function retrieves the minimum distance.\nFor example, try the following query which will provide the distance in metres between two of the petrol stations.\nSELECT ST_Distance(a.location, b.location, use_spheroid:=true) \nFROM petrolstation a, petrolstation b \nWHERE a.name='BP' and b.name='Shell';\n\n\n\n\n\n\nYour Turn\n\n\n\n\nWrite a query to find the distances between all pairs of petrol stations.\nSelect the names of the 10 closest restaurants from the restaurant poi_id = 33625120(us_restaurants table).\n\n\n\nWe can also find places that are within a certain distance of each other using the ST_DWithin function. Try the following query, inserting a range of sensible values in place of the distance ___:\nSELECT *\nFROM petrolstation a, petrolstation b\nWHERE ST_DWithin(a.location, b.location, ___);\n\n\n\nA buffer creates a new geometry containing all the locations within a specified distance of a input geometry. Create buffers of 1 km around each of the petrol stations, using the following template:\nSELECT ST_Buffer(geometry_column, distance)\nFROM ...;\nAgain, beware of the units!\nWe can also create the centroid (center of gravity) for a polygonal shape using the following template:\nSELECT ST_Centroid(geometry) \nFROM ...;\n\n\n\n\n\n\nYour Turn\n\n\n\n\nFind the centroid of the buffer of 1000 m for the Shell petrol station. What do you notice about this centroid and why?\nUse QGIS to visualise 1000 m buffers around all the us_restaurants. Are there any parts of Washington, DC that are more than 1000 m away from a restaurant?\n\n\n\n\n\n\nSome geometries may be of type GeometryCollection or Multi..., when there are multiple member geometries. It is then convenient to check how many geometry parts are in a multi-geometry, and to access these parts, for instance separating multi-geometries into components.\nYou can form a GeometryCollection or Multi* geometry using ST_Collect:\nSELECT ST_Collect(geom)\nFROM ...\nNote this is an aggregate function (like SUM or AVG), so it will take many rows and return a single value.\nThe reverse operation – splitting a GeometryCollection out into its component parts – is done using ST_Dump:\nSELECT (ST_Dump(geom_coll)).geom\nFROM ...\nYou can explore the part of PostGIS documentation related to GeometryCollections.\n\n\n\n\n\n\nYour Turn\n\n\n\n\nUse the ST_Collect and ST_Area functions to calculate the total area of all US states. Compare this with the area of the United States geometry in the world_counties table.\nAccording to the data in the world_countries table, how many islands (individual polygons) is Australia made up of? Use ST_Dump in your SQL query to answer this question.\n\n\n\n\n\n\nLinear referencing deal with positioning along linear geometries (e.g., “where does this point fall along a road/river/rail?”). That is not just a geometric property (like area/perimeter), but a form of spatial analysis specific to linear data.\n\nST_LineLocatePoint function in PostGIS provides the fractional position of a point along a line. It returns a number between 0 and 1 (0 → start of the line, 1 → end of the line, and e.g., 0.25 → the point is 25% along the line from the start):\n\nSELECT ST_LineLocatePoint(line_geom, point_geom)\nFROM ...\n\nST_LineInterpolatePoint is a PostGIS function used in geometrical analysis to find an exact position of a point along a line at a specified fractional distance. It returns a POINT geometry at the specified fraction along the line:\n\nSELECT ST_LineInterpolatePoint(line_geometry, fraction)\nFROM ...\n\n\n\n\n\n\nYour Turn\n\n\n\n\nFor route 31 in the table spatial.ptv_bus_routes, what are the linear reference positions of bus stops (spatial.ptv_bus_stops) located within 50 metres of the route? Provide each stop’s fraction along the route and its distance in metres from the start of the route.\nUsing the results from the previous step, write a query to compute the exact coordinates of each bus stop along the route.\nVisualise the resulting bus stops and their positions along the route in QGIS.\n\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\nUse the following sql:\n\nSELECT \n    r.id AS route_id,\n    st.id AS stop_id,\n    ST_LineLocatePoint(ST_LineMerge(ST_Transform(r.geom, 7855)),\n                       ST_Transform(st.geom, 7855)) AS stop_position_fraction,\n    ST_LineLocatePoint(ST_LineMerge(ST_Transform(r.geom, 7855)),\n                       ST_Transform(st.geom, 7855)) *\n    ST_Length(ST_LineMerge(ST_Transform(r.geom, 7855))) AS stop_position_meters\nFROM spatial.ptv_bus_stops st\nJOIN spatial.ptv_bus_routes r\n   ON r.id = 31\nWHERE ST_DWithin(ST_Transform(st.geom, 7855), \n                 ST_Transform(r.geom, 7855), 50)  -- only stops within 50 meters of route 68\nORDER BY stop_position_meters, st.id;\n\nUse the following sql:\n\nSELECT\n    r.id AS route_id,\n    st.id AS stop_id,\n    ST_LineLocatePoint(\n        ST_LineMerge(ST_Transform(r.geom, 7855)),\n        ST_Transform(st.geom, 7855)\n    ) AS stop_position_fraction,\n    ST_LineInterpolatePoint(\n        ST_LineMerge(ST_Transform(r.geom, 7855)),\n        ST_LineLocatePoint(\n            ST_LineMerge(ST_Transform(r.geom, 7855)),\n            ST_Transform(st.geom, 7855)\n        )\n    ) AS interpolated_point\nFROM spatial.ptv_bus_stations st\nJOIN spatial.ptv_bus_routes r\n    ON r.id = 31\nWHERE ST_DWithin(\n        ST_Transform(st.geom, 7855),\n        ST_Transform(r.geom, 7855),\n        50\n    )\nORDER BY stop_position_fraction, st.id;"
  },
  {
    "objectID": "P6_geometrical.html#extra-other-ways-of-importing-spatial-data",
    "href": "P6_geometrical.html#extra-other-ways-of-importing-spatial-data",
    "title": "[P6] Geometrical queries",
    "section": "",
    "text": "Other than creating data by hand, there are other means of creating content. This may be by modifying/computing geometrical content based on the existing content of other tables (or even the same one), parsing content from textual sources (importing text with coordinates and parsing this into e.g., points through the same processes investigated above), or importing content from GIS tools, or through ETL (Extract-Transform-Load) processes.\nSome hints are below.\n\n\nData can be created from a join, based on other tables. Note that below, you could add a functions to the SQL statement geom = t2.geom, e.g., geom = ST(centroid(t2.geom). What would that do?\nUPDATE petrolstation as t1\nSET geom = t2.geom \nFROM otherschema.pois as t2\nWHERE t1.attribute1 = t2.attribute2;\n\n\n\n\nFrom a GIS: experiment with QGIS, and try to export/save data from a shapefile into the database. This is now as easy as establishing a connection to your database in the Browser panel, and dragging some layers of data (e.g., hand digitised, or from a shapefile or similar format) from the Layers panel into the schema. Of course, you can be more nuanced.\nFrom an ETL (extract-transform-load) tool, e.g., FME, GDAL.org/ogr2ogr (excellent command line conversion utility). You can experiment with the tool ogr2ogr which is part of the QGIS installation (it is what actually powers QGIS). This is one of the most powerful tools in geospatial.\n\n\n\n\n\n\n\nTip\n\n\n\nLearn more: A detailed set of instructions for various import means is here: https://postgis.net/workshops/en/postgis-intro/loading_data.html"
  },
  {
    "objectID": "P6_geometrical.html#resources",
    "href": "P6_geometrical.html#resources",
    "title": "[P6] Geometrical queries",
    "section": "",
    "text": "PostGIS documentation: https://postgis.net/documentation/"
  },
  {
    "objectID": "P6_geometrical.html#footnotes",
    "href": "P6_geometrical.html#footnotes",
    "title": "[P6] Geometrical queries",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nYou can experiment: QGIS behaviour / ArcGIS: single column, create a view↩︎"
  }
]